<!DOCTYPE html>
<html lang="">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/note/shell.png">
    

    <title>
        
          kaiiiz/note
        
    </title>

    <!-- Spectre.css framework (v0.5.8) -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/note/css/spectre_custom.css">
    <link rel="stylesheet" href="/note/css/book.css">
    <script src="/note/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-112717568-2', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      <div class="column col-2 hide-lg">
        <div class="book-sidebar">
  <h4 class="site-meta">
    <a href="/note/">kaiiiz/note</a>
  </h4>
  <div class="sidebar-content">
    <ul>
<li><a href="/note">首頁</a></li>
<li><a href="/note/1072/sophomore">大二</a></li>
<li>大三</li>
<li>大四</li>
<li>英語相關
<ul>
<li><a href="/note/english-learning/grammar">文法</a></li>
</ul>
</li>
<li>網路相關
<ul>
<li><a href="/note/network-associate/landesign">LAN Design</a></li>
<li>Layer 2
<ul>
<li><a href="/note/network-associate/layer2/vlan">VLAN</a></li>
<li><a href="/note/network-associate/layer2/vtp">VTP</a></li>
<li><a href="/note/network-associate/layer2/stp">STP</a></li>
</ul>
</li>
<li>Layer 3
<ul>
<li><a href="/note/network-associate/layer3/routing">Routing</a></li>
<li><a href="/note/network-associate/layer3/vlsm">VLSM</a></li>
<li><a href="/note/network-associate/layer3/ospf">OSPF</a></li>
<li><a href="/note/network-associate/layer3/redistribution">Redistribution</a></li>
<li><a href="/note/network-associate/layer3/packet-switching">Packet Switching</a></li>
<li><a href="/note/network-associate/layer3/pbr">PBR</a></li>
<li><a href="/note/network-associate/layer3/vrf">VRF</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script src="/note/js/book-sidebar.js"></script>
      </div>

      <div class="column col-8 col-lg-12">
        <div class="book-content">
          <div class="book-navbar">
  <header class="navbar">
  <section class="navbar-section">
    <img class="navbar-icon" src="/note/shell.png">
  </section>
  <section class="navbar-center">
    kaiiiz/note
  </section>
  <section class="navbar-section">
    <label class="accordion-header c-hand" for="accordion-sidebar">
      <i class="icon icon-menu"></i>
    </label>
  </section>
</header>

<div class="accordion">
  <input type="checkbox" id="accordion-sidebar" name="accordion-checkbox" hidden>
  <div class="accordion-body">
    <ul>
<li><a href="/note">首頁</a></li>
<li><a href="/note/1072/sophomore">大二</a></li>
<li>大三</li>
<li>大四</li>
<li>英語相關
<ul>
<li><a href="/note/english-learning/grammar">文法</a></li>
</ul>
</li>
<li>網路相關
<ul>
<li><a href="/note/network-associate/landesign">LAN Design</a></li>
<li>Layer 2
<ul>
<li><a href="/note/network-associate/layer2/vlan">VLAN</a></li>
<li><a href="/note/network-associate/layer2/vtp">VTP</a></li>
<li><a href="/note/network-associate/layer2/stp">STP</a></li>
</ul>
</li>
<li>Layer 3
<ul>
<li><a href="/note/network-associate/layer3/routing">Routing</a></li>
<li><a href="/note/network-associate/layer3/vlsm">VLSM</a></li>
<li><a href="/note/network-associate/layer3/ospf">OSPF</a></li>
<li><a href="/note/network-associate/layer3/redistribution">Redistribution</a></li>
<li><a href="/note/network-associate/layer3/packet-switching">Packet Switching</a></li>
<li><a href="/note/network-associate/layer3/pbr">PBR</a></li>
<li><a href="/note/network-associate/layer3/vrf">VRF</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>
</div>

<div class="book-post">
  <h1 id="ospf">OSPF</h1>
<p>OSPF 主要分為三個階段：</p>
<ol>
<li>尋找鄰居：在兩台路由器上判斷是否需要交換拓樸資料</li>
<li>交換拓樸資料庫：路由器將資料存在 LSDB 上，LSDB 包含：
<ul>
<li>Router 的資訊
<ul>
<li>RID、Interface、IP、Netmask、Subnet</li>
</ul>
</li>
<li>在每個 Interface 可以到達的 Router 清單</li>
</ul>
</li>
<li>路徑計算：由自己為出發點計算到其他 Router 的最短距離，選出每個子網路最好的 net-hop，將之加入 IP 路由表中</li>
</ol>
<h2 id="區域">區域</h2>
<p>每個 Router 上的 Interface 都屬於同一個 Area，而一些特殊的<mark><strong>區域邊界路由器</strong>（Area Border Routers, ABR）</mark>則位在區域的界線上。</p>
<ul>
<li>區域0稱為<mark><strong>骨幹區域</strong>（backbone area）</mark>，負責連接所有其他區域。</li>
<li>在兩個非骨幹區域之間通過的封包必須經過至少一台的骨幹路由器。</li>
</ul>
<p><img src="2019-06-04-00-09-43.png" alt="典型的階層式OSPF設計"></p>
<p>在同一個區域的 Router 互相交換詳細的拓樸資訊，不同區域則透過 ABR 做簡短的通知（子網路/遮罩），但不包含其他區域的拓樸細節。</p>
<p><img src="2019-06-04-00-10-46.png" alt="Summary"></p>
<p>以拓樸來看，來自其他區域的子網路均視為直接連接到此 ABR。</p>
<h2 id="ospf術語名稱">OSPF術語名稱</h2>
<p>SPF (Shortest Path First，最短路徑優先)</p>
<blockquote>
<p>OSPF分析LSDB的演算法，以便決定最佳(最低成本)的路徑。</p>
</blockquote>
<p>LSDB (Link-state database，鏈路狀態資料庫)</p>
<blockquote>
<p>OSPF存放拓樸資料的資料結構。</p>
</blockquote>
<p>LSU (Link-state Update，鏈路狀態更新)</p>
<blockquote>
<p>OSPF封包的名稱。包含拓樸的詳細資訊，特別是LSA。</p>
</blockquote>
<p>LSA (Link-state Advertisement，鏈路狀態通告)</p>
<blockquote>
<p>具有拓樸資訊的OSPF資料結構。LSA存放在LSDB中，在網路上透過LSU訊息傳送。</p>
</blockquote>
<p>ABR (Area Border Router，區域邊界路由器)</p>
<blockquote>
<p>至少連接到兩個區域的路由器，ABR保存每個區域的拓樸資料、計算每個區域的路徑，並負責交換區域之間的路徑。</p>
</blockquote>
<p>DR (Designated Router，委任路由器)</p>
<blockquote>
<p>同一個網段中可能有多個 Router，假設每個 Router 需要建立 (n-1) 條連線，若 Fully Mesh 的連線總數為 n(n-1)/2</p>
<p>當 Router 越多連線數就越多，如此便多了很多不必要的通告。於是 OSPF 就在這些 Router 中選出一位 DR，所有 Router 只需與 DR 建立連線。</p>
<p>每次有 Routing Update，Router 只需把 Update 傳給 DR，再由 DR 統一發放給其他 Router，這樣，除了 DR 外， Area 裡每隻 Router 只需處理一條連線。</p>
</blockquote>
<p>BDR (Backup Designated Router，備用委任路由器)</p>
<blockquote>
<p>監控 DR，並在 DR 故障時接替它。</p>
</blockquote>
<h2 id="ospf功能摘要">OSPF功能摘要</h2>
<p>傳輸</p>
<blockquote>
<p>IP Protocal 89 (不使用 UDP、TCP)</p>
</blockquote>
<p>權值 (Metric)</p>
<blockquote>
<p>路徑中所有<mark>出境介面</mark>的成本總和</p>
</blockquote>
<p>Hello Interval</p>
<blockquote>
<p>路由器送出 OSPF Hello 的時間間隔</p>
</blockquote>
<p>Dead Interval</p>
<blockquote>
<p>路由器如果沒有在時間內收到任何 OSPF 訊息，會中止鄰居關係</p>
</blockquote>
<p>Update 封包之目的位址</p>
<blockquote>
<p>通常會送給 224.0.0.5 (所有SPF路由器) 以及 224.0.0.6 (所有的DR)</p>
</blockquote>
<p>完整或部份更新</p>
<blockquote>
<p>當探索到新鄰居後，執行完整更新。其餘使用部分更新</p>
</blockquote>
<p>驗證</p>
<blockquote>
<p>MD5/plain-text</p>
</blockquote>
<p>VLSM/無級式</p>
<blockquote>
<p>每一條路徑包含遮罩，也允許 OSPF 支援不連續的網路和 VLSM</p>
</blockquote>
<p>路徑標籤</p>
<blockquote>
<p>當路徑重分配 (redistribute) 到 OSPF 時，允許 OSPF 為路徑加上標籤</p>
</blockquote>
<p>Net-hop 欄位</p>
<blockquote>
<p>若通告此筆路徑的路由器，與此路徑所指向的 Net-hop 不同時，就會用到此欄位</p>
</blockquote>
<p>手動路徑彙整 (route summarization)</p>
<blockquote>
<p>只允許在 ABR 上做路徑彙整</p>
</blockquote>
<h2 id="在-lan-上的-ospf">在 LAN 上的 OSPF</h2>
<p>OSPF 在所有鄰居參數的核對都通過後，就會存在兩種鄰居關係：<strong>鄰居</strong>(neighbor)和<strong>完全相鄰</strong>(fully adjacent)關係。最後，OSPF 會使用具有 8 個狀態的 FSM，用於描述每一個 OSPF 鄰居目前的狀態。</p>
<h3 id="啟用鄰居探索">啟用鄰居探索</h3>
<ol>
<li>透過 <code>network</code> 或 <code>ip ospf area</code> 啟用 Interface 上的鄰居探索</li>
<li>Interface 尚未透過 <code>passive-interface</code> 設定為被動模式</li>
</ol>
<p>當滿足以上條件，OSPF 就會傳送 Hello 到 224.0.0.5 (OSPF的群播位置)，接著檢查 Hello 本身的 RID，以及路由器分配給 LAN 的 OSPF Area。</p>
<p><img src="2019-06-04-00-40-35.png" alt="群播 vs 廣播"></p>
<h3 id="建立鄰居關係所必須相符的設定">建立鄰居關係所必須相符的設定</h3>
<p>當收到其他路由器的 Hello，OSPF 就會發現準鄰居，接著就會開始比對資料，判斷是否可以成為鄰居。以下為參考資料：</p>
<ul>
<li>OSPF RID</li>
<li>末梢（Stub）區域標籤</li>
<li>Hello interval</li>
<li>Dead interval</li>
<li>Subnet mask</li>
<li>Interface 可到達的鄰居清單</li>
<li>Area ID</li>
<li>Router 的 Priority</li>
<li>DR 的 IP</li>
<li>BDR 的 IP</li>
<li>驗證摘要</li>
</ul>
<h3 id="ospf-rid-的唯一性">OSPF RID 的唯一性</h3>
<p>每個 OSPF 路由器都會為自己分配一個 RID，尋找順序如下：</p>
<ol>
<li>首先尋找 <code>router-id &lt;rid&gt;</code></li>
<li>尋找狀態為 up 的 loopback 最大的 IP</li>
<li>尋找 up 的 interface 最大的 IP</li>
</ol>
<p>若 OSPF RID 不遵守唯一性，學習網段時會與與形成鄰居的順序有關，如此會造成不可預期的結果。</p>
<blockquote>
<p>相同 OSPF RID 的兩台路由器無法形成鄰居關係。</p>
</blockquote>
<h3 id="使用相同的-ip-mtu">使用相同的 IP MTU</h3>
<p>介面的 MTU 是設定從 Interface 轉送出去的封包的最大尺寸。當路由器轉送的封包超過 MTU 時，路由器會對封包進行分段，如果 IP header 中的 <code>DF</code> (Don’t Fragment) 有設定，則會進行丟棄。</p>
<p>當兩個 OSPF 鄰居之間的 MTU 值不同時，其中一台路由器會試圖和其他 MTU 不同的路由器成為鄰居。</p>
<p>雖然路由器會出現在鄰居清單中 (透過 <code>show ip ospf neighbor</code> 列出的清單)，但這兩台路由器間<mark>不會交換拓樸資訊</mark>。且這兩台路由器計算路徑時，並不會將對方視為 Net-hop。</p>
<blockquote>
<p>拓樸資料的交換永遠不會成功，鄰居狀態：EXSTART &gt; DOWN &gt; 其中一台 Router 會再度嘗試 &gt; INIT</p>
</blockquote>
<h3 id="形成鄰居的必要條件">形成鄰居的必要條件</h3>
<ul>
<li>Interface 的 primary IP 必須屬於相同的子網路</li>
<li>直連介面不可以是 passive</li>
<li>相同的 Area</li>
<li>Hello interval 或 Dead interval 相符</li>
<li>RID 唯一</li>
<li>IP MTU 相符</li>
<li>必須通過鄰居的驗證（如果有設定的話）</li>
</ul>
<h2 id="在-wan-上的-ospf">在 WAN 上的 OSPF</h2>
<p>須滿足<a href="#%E5%BD%A2%E6%88%90%E9%84%B0%E5%B1%85%E7%9A%84%E5%BF%85%E8%A6%81%E6%A2%9D%E4%BB%B6">在 LAN 形成鄰居的必要條件</a>，此外在不同類型的 WAN 鏈路上仍須考量其他因素：</p>
<p>與 OSPF 網路類型相關:</p>
<ul>
<li>路由器是否使用 OSPF Hello 群播訊息來探索彼此，或者需要預先定義鄰居?</li>
<li>路由器會試著選出 DR 嗎？如果是的話，什麼樣的路由器有資格成為 DR?</li>
</ul>
<p>視 WAN 服務而定:</p>
<ul>
<li>每個路由器會和其他哪些路由器成為 OSPF 鄰居?</li>
</ul>
<h3 id="ospf-網路類型">OSPF 網路類型</h3>
<p>網路類型 (依介面設定) 主導了 OSPF 的運行方式：</p>
<ul>
<li>路由器是否能使用 Hello 探索鄰居</li>
<li>在連接的 Subnet 中是否存在兩台以上的 OSPF 路由器</li>
<li>在某介面中是否應該選出 OSPF DR</li>
</ul>
<p>舉例來說，點對點鏈路和點對點 WAN 子介面預設使用的網路類型是「點對點」，代表除了該子網路裡只能存在二部OSPF路由器，以及透過 Hello 動態地探索到鄰居之外，這二台路由器並不會選出 DR。</p>
<table>
<thead>
<tr>
<th>介面類型</th>
<th>使用 DR/BDR</th>
<th>預設的 Hello Interval</th>
<th>鄰居的動態探索</th>
<th>相同子網路支援多台路由器</th>
</tr>
</thead>
<tbody>
<tr>
<td>廣播</td>
<td>是</td>
<td>10</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>點對點</td>
<td>否</td>
<td>10</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>Loopback</td>
<td>否</td>
<td>-</td>
<td>-</td>
<td>否</td>
</tr>
<tr>
<td>非廣播 (NBMA)</td>
<td>是</td>
<td>30</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>點對多點</td>
<td>否</td>
<td>30</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>點對多點非廣播</td>
<td>否</td>
<td>30</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h4 id="點對點-p2p">點對點(P2P)</h4>
<p><img src="2019-06-04-01-14-03.png" alt></p>
<ul>
<li>這條 link 兩端只有 2 個 point，互為 neighbor</li>
<li>在其中一端送，只會有另一端收</li>
</ul>
<h4 id="廣播-broadcast">廣播(broadcast)</h4>
<p><img src="2019-06-04-01-14-54.png" alt></p>
<ul>
<li>default network type</li>
<li>透過 broadcast 的方式傳送 OSPF packet</li>
<li>高擴展性，加入新 router 時，只需要設定新 router 即可</li>
<li>選 DR 和 BDR，防止更新路徑時傳送過多的 packet</li>
</ul>
<h4 id="非廣播-non-broadcast">非廣播(Non Broadcast)</h4>
<p><img src="2019-06-04-01-15-18.png" alt></p>
<ul>
<li>處理網路 protocol 不支援 broadcast，EX : frame-relay, ATM (PVCs)</li>
<li>在交流之前，需要先知道對方是誰</li>
<li>要傳給 n 個 neighbor，需要 ruplicate n 次</li>
</ul>
<p>又分為:</p>
<ul>
<li>Point to Broadcast
<ul>
<li>不模擬 broadcast 的方式，而是把多個 point-to-point 的組成 PVCs(Permenent Virtual Circuit)</li>
<li>需要 ruplicate OSPF packet 傳送給多個 neighbor</li>
<li>不選 DR/BDR</li>
<li>這些 point-to-point link 可以使用同一個子網路</li>
</ul>
</li>
<li>Non-Broadcast Multi-Access (NBMA)
<ul>
<li>需要設定每個 neighbor 的 IP</li>
<li>用 unicast 模擬 broadcast 的方式</li>
<li>有選 DR/BDR</li>
</ul>
</li>
</ul>
<h3 id="鄰居關係">鄰居關係</h3>
<h4 id="訊框中繼點對點連線">訊框中繼點對點連線</h4>
<p>將一對 VPC 兩端的路由器視為點對點拓樸，並分配一個子網路給每一對的路由器。</p>
<p><img src="2019-06-04-01-23-17.png" alt></p>
<h4 id="mlps-vpn">MLPS VPN</h4>
<blockquote>
<p>多重協定標籤交換技術 (Multiprotocol Label Switching，MLPS)</p>
</blockquote>
<p>使用 Layer 3 傳遞，所以客戶端的路由器不用事先定義 PVC。</p>
<p>在服務供應商的網路邊界上，有 Layer 3-aware 的 PE (Provider edge)。與另一端 Layer 3-aware 的 CE (Customer edge) 相連，形成 OSPF 鄰居。</p>
<p><img src="2019-06-04-01-30-44.png" alt></p>
<h4 id="都會型乙太網路">都會型乙太網路</h4>
<p>因為都會型乙太網路提供 Layer 2 的連線，所以客戶的路由器不會和服務供應商網路內的路由器形成 OSPF 鄰居，而是在客戶端間產生，使得該服務就像是大型的 WAN。</p>
<p><img src="2019-06-04-01-31-43.png" alt></p>
<h2 id="ospf-虛擬鏈路">OSPF 虛擬鏈路</h2>
<p>在某些情況可能存在兩個骨幹區域，換句話說，有時非骨幹區域可能不方便直接連接到骨幹區域，舉例來說：</p>
<ol>
<li>現有網路需要加入新的區域，但新的區域沒有直接連接到Area 0</li>
</ol>
<p><img src="2019-06-04-01-36-32.png" alt></p>
<ol start="2">
<li>Area 0 中的鏈路斷路，形成一分為二的拓樸</li>
</ol>
<p><img src="2019-06-04-01-36-44.png" alt></p>
<h3 id="概念">概念</h3>
<p>OSPF 虛擬鏈路支援兩台連接到<mark>相同非骨幹區域的 ABR</mark>，即使被許多其他路由器與子網路隔開，也能經由非骨幹區域建立鄰居關係。好比兩台路由器間位在 Area 0 的虛擬的點對點連線。</p>
<p><img src="2019-06-04-01-39-20.png" alt="在 Area 0 的路由器不但可以建立鄰居關係，也能在鏈路上 flood LSA"></p>
<ul>
<li>若要設定虛擬鏈路，兩台路由器都要設定對方的 RID，並參考到虛擬鏈路所通過的 Area</li>
<li>兩台路由器傳送一般的 OSPF 訊息類型，封裝在單點傳送 IP 封包，目的地為虛擬鏈路另一端的 IP 位址</li>
</ul>
<p>虛擬鏈路兩端的 ABR 與其他普通的 ABR 運作大抵相同，除了：</p>
<ol>
<li>以<mark>單點</mark>傳送將所有的 OSPF 訊息傳送到鏈路另一端</li>
<li>會在 LSA 上標示 DNA（Do Not Age，沒有期限），代表虛擬鏈路另一端的路由器，<mark>不必在平常 30 分鐘重整間隔期間重新洪泛 LSA 到虛擬鏈路上</mark>。</li>
<li>路由器可以替虛擬鏈路指定 OSPF 成本</li>
</ol>
<h3 id="設定">設定</h3>
<p>使用 <code>area virtual-link</code> 命令加上參數</p>
<p>注意:</p>
<ul>
<li>兩台路由器連接的中繼區域不可以是末梢(stubby)區域</li>
<li>OSPF 鄰居驗證參數 (optional)</li>
<li>Hello interval, Dead interval (optional)</li>
<li>OSPF 成本</li>
</ul>
<h3 id="檢驗">檢驗</h3>
<p><code>show ip ospf virtual-links</code></p>
<p><code>show ip ospf neighbor</code></p>
<h2 id="lsa">LSA</h2>
<table>
<thead>
<tr>
<th>LSA 類型</th>
<th>一般名稱</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Router</td>
<td>每個路由器都會建立自己的第 1 型 LSA, 用來描述本身連接到的每個區域。</td>
</tr>
<tr>
<td>2</td>
<td>Network</td>
<td>每個傳輸網路會有一個第 2 型 LSA。</td>
</tr>
<tr>
<td>3</td>
<td>Net Summary</td>
<td>由 ABR 建立並通告到其他區域，描述一個區域的第 1、2 型 LSA 所列的子網路。</td>
</tr>
<tr>
<td>4</td>
<td>ASBR Summary</td>
<td>類似於第 3 型 LSA, 但會通告一條用來到達 ASBR 的主機路徑。</td>
</tr>
<tr>
<td>5</td>
<td>AS External</td>
<td>由 ASBR 建立，負責將外部路徑傳到 OSPF 裡。</td>
</tr>
<tr>
<td>6</td>
<td>Group Membership</td>
<td>針對MOSPF而定義，Cisco IOS並不支援。</td>
</tr>
<tr>
<td>7</td>
<td>NSSA External</td>
<td>由NSSA區域內的ASBR所建立，以代替第5型LSA。</td>
</tr>
<tr>
<td>8</td>
<td>Link LSA</td>
<td>只存在於本地鏈路的第 8 型 LSA· 路由器用來通告其鏈路區域位址給相同鏈路上的其他路由器。</td>
</tr>
<tr>
<td>9</td>
<td>Intra-Area Prefix LSA</td>
<td>用來傳送關於連接路由器的1Pv6網路（包括末梢網路）， 類似1Pv4網路的第1型LSA。</td>
</tr>
<tr>
<td>10-11</td>
<td>Opaque</td>
<td>作為一般用途的LSA, 方便OSPF日後的擴充。</td>
</tr>
</tbody>
</table>
<h2 id="內部-lsa">內部 LSA</h2>
<p>OSPF 使用第 1、2、3 型 LSA 來計算 OSPF 領域內所有路由的最佳路徑。在後面會介紹使用 4、5、7 型 LSA 來計算外部路徑 (將路徑重新分配到 OSPF)。</p>
<h3 id="第-1-型">第 1 型</h3>
<p>又稱為 Router LSA，根據 OSPF RID 來識別 OSPF 路由器。<mark>每個路由器</mark>本身會建立第 1 型LSA。並將此 LSA 洪泛到相同的整個區域。</p>
<p>OSPF 使用 32-bits 的 LSID (link-state identifier) 來辨識第一型 LSA，建立 LSID 時，會使用自己的 RID 當作 LSID。</p>
<ul>
<li>區域內部的每個路由器本身會建立一個第 1 型 LSA。</li>
<li>ABR 會建立多個第 1 型 LSA：每個區域一個。</li>
</ul>
<p>傳送資訊:</p>
<ul>
<li>對於每個沒有選出 DR 的介面，第 1 型 LSA 列有該路由器的 interface network id / netmask 與 interface 的 OSPF 成本。OSPF將這些子網路稱之為<strong>末梢綱路</strong>。</li>
<li>對於每個選出 DR 的介面，則列舉 DR 的 IP 位址與連接至傳輸網路的標記 (意指該網路存在第2型LSA)。</li>
<li>對於每個無 DR 的介面，若可以到達鄰居，則會列舉該鄰居的 RID。</li>
</ul>
<p><img src="2019-06-06-16-24-15.png" alt></p>
<p>以區域 5 為例，有一台內部路由器 R5，以及兩台 ABR R1、R2，這三台路由器各自建立第 1 型 LSA 並 flood 到區域 5 中，且都知道這 3 個相同的第 1 型 LSA。</p>
<p><img src="2019-06-06-16-28-57.png" alt="在區域 5 中的 3 個第 1 型 LSA"></p>
<p>R5 的第 1 型 LSA 資訊:</p>
<ul>
<li>LSID 5.5.5.5</li>
<li>連結到末梢網路的三條鏈路，每條都包含子網路/遮罩</li>
<li>兩條鏈路連到鄰居 R1、R2</li>
</ul>
<h3 id="第-2-型">第 2 型</h3>
<p>又稱為 Network LSA，SPF 要求 LSDB 建構出來的拓樸必須具備節點 (路由器) 以及節點之間的連接 (鏈路)。OSPF必須以某種方式建構出區域網路，使得拓樸能夠呈現節點與鏈路。為了滿足需求，OSPF 使用了第 2 型 Network LSA 來解決問題。</p>
<blockquote>
<p>實際上 ，OSPF 是根據介面上是否選出 DR，來選擇多重存取網路是否使用第 2 型 LSA。</p>
</blockquote>
<h4 id="dr">DR</h4>
<p>使用DR的主要目的：</p>
<ul>
<li>建立第 2 型 Network LSA 並 flood 到該子網路。</li>
<li>協助子網路上資料庫交換</li>
</ul>
<p>當 DR 和 BDR 都還不存在的時候，路由器使用以下規則：</p>
<ul>
<li>選擇具有最高優先權（<code>ip ospf priority value</code>，default 1，max 255) 的路由器</li>
<li>若優先權相同，則選擇 RID 最高的路由器</li>
<li>根據次佳的優先權來選擇 BDR。如果優先權相同，則選擇次佳的 RID</li>
</ul>
<p>當 DR 和 BDR 都存在的情況：</p>
<ul>
<li>DR 斷線，BDR 成為 DR，選新 BDR</li>
<li>BDR 斷線，直接選 BDR</li>
</ul>
<h4 id="概念-v2">概念</h4>
<p>為了滿足「一條鏈路只能連到兩個節點」，OSPF 使用第 2 型 LSA 來建構多重存取網路 (超過2部以上的路由器連到相同子網路)</p>
<p><img src="2019-06-06-17-00-34.png" alt></p>
<p>以上圖為例，由於 OSPF 無法讓 4 台路由器只透過一條鏈路連接到同一個子網路，因此 OSPF 定義了第 2 型 Network LSA 來做為虛擬節點 (pseudonode)。每個路由器的第 1 型 Router LSA 會列出至此虛擬節點的連結，再利用第 2 型 Network LSA 來建立它。</p>
<p><img src="2019-06-06-17-03-32.png" alt></p>
<h4 id="例子">例子</h4>
<p><img src="2019-06-06-16-24-15.png" alt></p>
<p>以區域 34 為例，R3、R4 連到相同的區域網路，代表會選出 DR (當至少有 2 台路由器滿足建立鄰居的必要條件時，就會成為鄰居，接著 OSPF 會在 LAN 上選出 DR)，若 R3、R4 優先權相同，則 R4 成為 DR。所以，R4 在該子網路中建立了第 2 型 LSA 並 flood，如下圖所示：</p>
<p><img src="2019-06-06-17-10-41.png" alt></p>
<p>由此可知，OSPF 利用第 1 型、第 2 型 LSA 來建構出單一區域內所有的拓樸。一旦路由器使用 SPF 程序建立拓樸模型後，接下來就可以計算該區域裡每個子網路的「最佳路徑」。</p>
<h3 id="第-3-型">第 3 型</h3>
<p>又稱為 Summary LSA，為了不讓所有路由器都知道 OSPF 領域中全部的第 1、2 型 LSA，ABR 並不會從某個區域將第 1、2 型 LSA 轉送到另一個區域中，反之亦然。如此可以縮小 LSDB，進而節省記憶體與縮短收斂時間等。</p>
<p>ABR 不將第 1、2 型 LSA 轉送到另一個區域中，而是用第 3 型 LSA (Summary LSA) 來通告這些區域的路徑。ABR 會替一個區域裡的<mark>每個子網路</mark>產生一個第 3 型 LSA，再把每個第 3 型 LSA 通告到其他區域裡。第3型 LSA (Summary LSA) 不包含所有拓樸的詳細資訊，僅負責彙整網段的資訊。</p>
<p><img src="2019-06-06-16-24-15.png" alt></p>
<p><img src="2019-06-06-17-25-01.png" alt="單個區域的 LSDB"></p>
<p><img src="2019-06-06-17-26-07.png" alt="三個區域的 LSDB"></p>
<p>ABR 負責建立第 3 型 LSA 並 flood 到下一個區域裡。ABR 會替通告的子網段位址冠上 LSID，並將自己的 RID 新增到 LSA。(這樣路由器才知道是哪個 ABR 通告了該路徑)</p>
<blockquote>
<p>使用第 3 型 LSA 之目的並非為了彙整路徑。這裡的 “Summary” 只是相較第 1、2 型 LSA 的詳細資訊表示較精簡的意思。</p>
</blockquote>
<h3 id="限制-lsa-數量">限制 LSA 數量</h3>
<p><code>max-lsa number</code>，避免記憶體不足，假設超過 LSA 上限：</p>
<ol>
<li>log</li>
<li>忽略與等待所有鄰居關係中止</li>
<li>刪除 LSDB</li>
<li>重新新增鄰居</li>
</ol>
<h3 id="摘要">摘要</h3>
<table>
<thead>
<tr>
<th>類型</th>
<th>名稱</th>
<th>意義</th>
<th>LSID</th>
<th>建立者</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Router</td>
<td>一台路由器</td>
<td>路由器的 RID</td>
<td>每台路由器都會自行產生</td>
</tr>
<tr>
<td>2</td>
<td>Network</td>
<td>存在 DR 的子網路</td>
<td>改子網路中 DR 的 IP</td>
<td>子網路裡的 DR</td>
</tr>
<tr>
<td>3</td>
<td>Summary</td>
<td>另一個區域內的子網路</td>
<td>子網路編號</td>
<td>ABR</td>
</tr>
</tbody>
</table>
<h2 id="資料庫交換程序">資料庫交換程序</h2>
<p>當拓樸交換完畢後，對區域內的路由器而言，該區域的 LSDB 理應一致。內部路由器只會有該區域的 LSA，ABR 則會包含所有連接區域的 LSA。OSPF 路由器洪泛它們所建立的 LSA，並從它們的鄰居學到新的 LSA，直到同區域所有路由器都擁有最新的 LSA 副本為止。</p>
<h3 id="ospf訊息類型">OSPF訊息類型</h3>
<table>
<thead>
<tr>
<th>訊息名稱/編號</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hello</td>
<td>用於探索鄰居、建立雙向鄰居關係與監控鄰居回應</td>
</tr>
<tr>
<td>資料庫描述 (DD/DBD)</td>
<td>用於交換每個簡要的 LSA 一般用在初始的拓樸交換</td>
</tr>
<tr>
<td>鏈路狀態要求 (LSR)</td>
<td>列舉 LSA 的 LSID 的一種封包</td>
</tr>
<tr>
<td>鏈路狀態更新 (LSU)</td>
<td>包含完整 LSA 詳細資訊的一種封包，用以回應 LSR 訊息</td>
</tr>
<tr>
<td>鏈路狀態確認 (LSAck)</td>
<td>用來確認收到LSU訊息所傳送的封包</td>
</tr>
</tbody>
</table>
<h3 id="ospf鄰厝狀態">OSPF鄰厝狀態</h3>
<table>
<thead>
<tr>
<th>狀態</th>
<th>意義</th>
</tr>
</thead>
<tbody>
<tr>
<td>Down</td>
<td>超過 Dead Interval 後仍沒有收到來自此鄰居的 Hello</td>
</tr>
<tr>
<td>Attempt</td>
<td>利用 <code>neighbor</code> 命令定義鄰居時，在傳送 Hello 後並收到鄰居的 Hello 前的這段時閒所使用的狀態</td>
</tr>
<tr>
<td>Init</td>
<td>鄰居已收到本地路由器的 Hello 封包，但 Hello 參數不符時所使用的一種永久狀態</td>
</tr>
<tr>
<td>2-Way</td>
<td>鄰居已收到 Hello，Hello 包含了路由器的 RID，並通過所有鄰居的檢驗</td>
</tr>
<tr>
<td>ExStart</td>
<td>目前協商用於 DD 封包的 DD 序號與主從關係</td>
</tr>
<tr>
<td>Exchange</td>
<td>完成 DD 程序詳細資訊的協商，且目前正在交換 DD 封包</td>
</tr>
<tr>
<td>Loading</td>
<td>所有的 DD 封包交換完畢，且路由器目前正在傳送 LSR、LSU 及 LSAck 來交換完整的LSA</td>
</tr>
<tr>
<td>Full</td>
<td>與鄰居形成了完全相鄰關係，意指它們該區域的 LSDB 完全相同，並開始計算路由表</td>
</tr>
</tbody>
</table>
<h3 id="無dr情況下的交換">無DR情況下的交換</h3>
<p>每個 OSPF 鄰居關係的建立是由交換 Hello 開始，直到鄰居 (有希望) 達到 2-Way 狀態為止。在路由器收到 Hello 並確認所有必要的參數均相符之後，路由器會在 Hello 裡列舉已見過的另一台路由器之 RID。</p>
<p><img src="2019-06-08-00-07-30.png" alt></p>
<p>當路由器與鄰居都達到 2-Way 狀態時，路由器要來決定是否交換它的 LSDB。在沒有 DR 存在的情況下一定會回答「yes」，程序如下：</p>
<ol>
<li>探索鄰居已經知道但自己尚未知道的 LSA</li>
<li>探索路由器雙方已經知道的 LSA，但鄰居的 LSA 是比較新的</li>
<li>向鄰居要求所有步驟1與步驟2所識別的 LSA 之副本</li>
</ol>
<p>在路由器進入2-Way 並決定與鄰居交換 LDSB 後，會進行以下步驟：</p>
<p><img src="2019-06-08-00-12-36.png" alt></p>
<h4 id="探索鄰居lsdb的內容">探索鄰居LSDB的內容</h4>
<p>每個鄰居的主要目標是要瞭解區域內的哪個 LSA 還不知道，因此會要求路由器雙方要將所有已知該區域內的 LSA 之 LSID 告訴彼此。為了學到鄰居已知的 LSA 清單，鄰居路由器會遵循以下的步驟：</p>
<ol>
<li>將資料庫描述封包(DD/DBD)傳送到 SPF 路由器的 224.0.0.5 群播位址</li>
<li>當傳送第1個 DD 訊息時，就會進入「ExStart」狀態，直到其中一台 RID 較高的路由器成為 master 為止</li>
<li>在選出 master 之後 ，鄰居開始進入「Exchange」狀態</li>
<li>彼此繼續送出 DD 群播訊息給對方，直到路由器雙方已知兩者所收集的該區域之 LSID 都一樣為止</li>
</ol>
<blockquote>
<p>DD 訊息本身僅有 LSA 標頭，不包含整個 LSA。這些標頭包含了 LSA 的 LSID 和序號。</p>
<p>最初建立的 LSA 之 LS序號是從 0x80000001 開始；每當 LSA 變更時，建立 LSA 的路由器就會增加序號，然後重新洪泛此 LSA。</p>
</blockquote>
<p>對於每次的交換，master 會利用 slave 回應給 master 的 DD 訊息，來控制 DD 訊息的流向。master 會持續送出 DD 訊息，直到列舉該區域裡所有已經知道的 LSID 為止。</p>
<p>直到每一台路由器都知道本身 LSDB 裡所缺少的 LSA，但其他路由已有的 LSA 之清單後，才會結束 DD 訊息的交換。</p>
<h4 id="交換lsa">交換LSA</h4>
<p>當二個鄰居認知到它們有著一份相同的 LSID 清單時，它們便會進入到「Loading」狀態；就它們尚未知道或已改變的部分，開始交換完整的 LSA。</p>
<ol>
<li>鄰居進入「Loading」狀態</li>
<li>就任何缺少 LSA 的情況而言，會傳送「鏈路狀態要求(LSR)」，該訊息列舉要求 LSA 的 LSID</li>
<li>利用 LSU 回應 LSR，每個訊息列舉一個以上的 LSA</li>
<li>傳送「鏈路狀態確認(LSAck) 」訊息 (明確確認) 或以 LSU 訊息 (隠含確認) 將所收到的相同 LSA 傳回給另一台路由器，來進行回覆確認</li>
<li>當傳送、接收以及確認完所有的LSA時，鄰居關係將轉變為 FULL 狀態 (完全相鄰)。</li>
</ol>
<p>程序的最後，雙方路由器應該會有一份完全相同的 LSDB。此時，這2台路由器可以開始執行 SPF 演算法，選出目前抵達每個子網路的最佳路徑。</p>
<h3 id="有dr情況下的交換">有DR情況下的交換</h3>
<p>程序大多數的步驟是相似的(相同的訊息、意義，以及鄰居狀態)，最大的差別在於每個路由器選擇執行資料庫交換的覆寫方式。</p>
<p>同一子網路上，非 DR 的路由器不會直接與所有的鄰居交換它們的資料庫，而是與 DR 進行交換。接著，DR 會和子網路中其他的 OSPF 路由器交換所有新的或已變更的 LSA。</p>
<p><img src="2019-06-08-00-38-53.png" alt></p>
<ul>
<li>4 個第1型 LSA，代表位於相同 LAN 的 4 台真實路由器</li>
<li>1 個第2型 LSA，代表多重存取子網路，此時 DR 扮演建立第2型 LSA 的角色</li>
</ul>
<p>2 步驟:</p>
<ol>
<li>非 DR 路由器以相同的訊息執行資料庫的交換，並傳送這些訊息到 DR 路由器 (第2型虛擬節點) 的 224.0.0.6 群播位址</li>
<li>DR 路由器 (第2型虛擬節點) 以相同的訊息執行資料庫的交換，但傳送這些訊息到所有 SPF 路由器的 224.0.0.5 群播位址</li>
</ol>
<p>也就是說，扮演虛擬節點腳色的 DR 會將 LSA 洪泛到子網路中的其他 OSPF 路由器。</p>
<p>在子網路中 DR 存在的情況下，DROther (非DR非BDR) 路由器僅與 DR 和 BDR 執行資料庫的交換。比方說，R1 扮演 DR，R2 扮演 BDR，R3/R4 扮演 DROther，由於邏輯上不允許 R3 與 R4 的資料庫交換，因此路由器不會達到 FULL 狀態，而是維持在 2-Way 狀態。</p>
<h3 id="洪泛到整個區域">洪泛到整個區域</h3>
<p>當路由器從某個鄰居學到新的 LSA 時，該路由器會認為在相同區域內的其他鄰居也許不知道此 LSA。也就是說當 LSA 改變時 (當介面狀態改變時)，路由器可能學到舊的 LSA，但其序號是新的，故需要再次將此變更的 LSA 洪泛到該區域中的其他鄰居。</p>
<p><img src="2019-06-08-00-52-29.png" alt></p>
<p>首先考慮 R1、R2，當 R1 開機後，R1 與 R2 達到 Full 狀態，並擁有相同區域1的 LSDB：</p>
<ul>
<li>R2 學到所有 R1 新的 LSA (僅 R1 的第1型 LSA)</li>
<li>R1 學到 R2 所知道的全部區域1的 LSA (包含 R3、R4 的第1型 LSA)</li>
</ul>
<p>接下來看關於 R3、R4 的 LSDB：</p>
<ul>
<li>當 R2 學到 R1 的第1型 LSA 後，會傳送 DD 封包到 R2、R3、R4 所連結的 LAN 之 DR</li>
<li>DR 產生 LSR/LSU，使得 R3、R4 可以收到 R1 的新 LSA</li>
<li>若有更多路由器存在區域1，洪泛程序會繼續傳遍整個區域，直到所有路由器知道每個 LSA 的最佳副本為止</li>
</ul>
<h3 id="定期洪泛">定期洪泛</h3>
<p>OSPF 會根據每個 LSA 的計時器，每 30 分鐘 (1800s) 重新洪泛一次。當路由器建立 LSA 時，會將計時器設為 0，如果 30 分鐘沒有任何變化，那麼擁有 LSA 的路由器會將序號增加、重新設定計時器為 0，並重新洪泛 LSA。</p>
<blockquote>
<p>當路由器需要針對區域從 LSDB 刷新 LSA 時，實際上會將 LSA 的計時器定為 MaxAge(3600) 並重新洪泛 LSA。所有其他路由器收到該 LSA 時，看到計時器已經是最大值，會從它們的LSDB 刪除該 LSA</p>
</blockquote>
<h2 id="選擇最佳的ospf路徑">選擇最佳的OSPF路徑</h2>
<ul>
<li>分析 LSDB，以便計算出到達子網路的所有可能路徑</li>
<li>對於每個可能的路徑，在該路徑的所有出境介面上增加 OSPF 的介面成本</li>
<li>挑選總成本最低的路徑</li>
</ul>
<h3 id="區域內路徑的成本計算">區域內路徑的成本計算</h3>
<ol>
<li>根據列在第1型 LSA 裡的末梢介面以及任何一個第2型 Network LSA，找出區域內所有的子網路</li>
<li>執行 SPF 以找到通過該區域拓樸的所有可能路徑 (從該拓樸到各子網路)</li>
<li>替每筆路徑裡的所有出境介面計算 OSPF 介面成本，並從每個子網路中，挑選總成本最低的路徑來作為最佳路徑</li>
</ol>
<p><img src="2019-06-08-01-23-53.png" alt></p>
<ol>
<li>R1 透過 DR 知道區域中存在 10.10.34.0/24 的子網路</li>
<li>R1 透過 SPF 決定 4 條可能的路徑</li>
<li>算出最佳路徑 R1-R3: 657, R1-R4: 657</li>
</ol>
<blockquote>
<p>當兩者的權值相同時，根據 <code>maximum-paths 4</code> 的預設值，R1 會將這兩2條路徑都新增到它的路由表中</p>
<p>OSPF 支援成本相等(equal-cost)的負載平衡，但不支援成本不等(unequal-cost)的負載平衡。<code>maximum-paths</code> 最低為 1，最大值則依據路由器平台和CiscoIOS版本而定。</p>
</blockquote>
<h3 id="區域間路徑的成本計算">區域間路徑的成本計算</h3>
<p>考慮 R3 如何找出到達 10.10.99.0/24 的最佳路徑</p>
<p><img src="2019-06-08-01-29-58.png" alt></p>
<p>由於區域設計的關係，R1 和 R2 扮演 ABR 的角色。R3 倚賴 ABR 所建立的第3型 LSA (Summary LSA)，其中的資訊如下：</p>
<ul>
<li>LSA 顯示的子網路編號/遮罩</li>
<li>ABR 到達子網路之最佳路徑的成本</li>
<li>ABR 的 RID</li>
</ul>
<p>計算最佳路徑的方法：</p>
<ol>
<li>計算從路由器到 ABR (由第3型LSA得知）的區域內成本</li>
<li>加上第3型 LSA 所列的成本值 (表示ABR到目的子網路之成本)</li>
</ol>
<p><img src="2019-06-08-01-35-20.png" alt></p>
<p>R3 也會對 ABR R2 做相同的事，選擇最佳路徑加到路由表中</p>
<h3 id="abr區域內與區域間的特例">ABR區域內與區域間的特例</h3>
<p>當超過一個以上的 ABR 同樣連接到 2 個區域時：</p>
<p><img src="2019-06-08-01-39-07.png" alt></p>
<ol>
<li>在選擇最佳路徑時，無論權值大小，區域內路徑永遠優於區域間路徑</li>
<li>如果 ABR 學到非骨幹區域的第3型 LSA，那麼 ABR 在計算自己的路徑時會忽略該 LSA (僅選擇自己的最佳 IP 路徑)</li>
</ol>
<h3 id="權值與spf計算">權值與SPF計算</h3>
<p>無論第3型 LSA 如何變更，並不影響路由器與 ABR 之間的拓樸。而 SPF 著重於處理拓樸資料，所以只有第1、2型 LSA 的改變才會要求 SPF 的計算。</p>
<p><code>show ip ospf</code> 可以查看 LSA 執行次數，以及最後一次執行到現在經過的時間。</p>
<h3 id="權值的調整">權值的調整</h3>
<ul>
<li>修改參照頻寬</li>
<li>設定介面頻寬</li>
<li>直接設定OSPF成本</li>
</ul>
<p>OSPF 根據下列公式來計算介面的預設成本：<mark>成本 = 參照頻寬 / 介面頻寬</mark></p>
<h4 id="修改參照頻寬">修改參照頻寬</h4>
<p><code>auto-cost reference-bandwidth [bandwidth]</code> (Mbps)</p>
<p>修改參照頻寬的主要動機，是為了提供高速鏈路理想的預設成本。藉由修改OSPF的參照頻寬，使得高速鏈路之間的成本產生些為差異，則OSPF就能在使用高速介面的路徑之間做出選擇。</p>
<h4 id="設定介面頻寬">設定介面頻寬</h4>
<p><code>bandwidth [speed]</code> (Kbps)</p>
<h4 id="直接設定成本">直接設定成本</h4>
<p><code>ip ospf cost [value]</code></p>
<h2 id="路徑篩選">路徑篩選</h2>
<p>防止網路某部份的主機傳送封包到另一個地方、減少路由表大小、CPU資源，讓封包的轉送執行的更順暢。</p>
<h3 id="區域內-區域間路徑計算">區域內/區域間路徑計算</h3>
<ul>
<li>區域內透過第一型、第二型 LSA 拼湊出拓樸，執行 SPF 尋找每個子網路可能路徑</li>
<li>區域間的路徑計算透過本身抵達 ABR 的權值，加上 ABR 通告目的地子網路子網路的權值，因此不需要 SPF 計算，就能找出所有子網路的區域間路徑</li>
</ul>
<h3 id="區域內-區域間路徑篩選">區域內/區域間路徑篩選</h3>
<p>OSPF 不是通告路徑，是通告 LSA，因此路徑篩選做的事就是在過濾特定 LSA</p>
<ul>
<li>OSPF 不允許過濾同一區域內的 LSA，特別是描述區域拓樸的第一型與第二型的 LSA
<ul>
<li>因為同一區域內的所有路由器都要有相同的 LSDB 才能進行 SPF 計算，否則可能造成迴圈</li>
</ul>
</li>
<li><mark>只能設定 ABR 過濾第三型 LSA 來達到路徑篩選</mark> (或是 ASBR 過濾第五型 LSA)</li>
</ul>
<h3 id="過濾第三型lsa">過濾第三型LSA</h3>
<p>告訴 ABR 要過濾某些 LSA 通告</p>
<p>舉例來說，計畫使區域1的所有封包到達不了子網路3，且僅可透過 ABR1 到達子網路2</p>
<p><img src="2019-07-03-16-09-15.png" alt></p>
<ul>
<li>在 ABR1 過濾子網路 3 的通告</li>
<li>在 ABR2 過濾子網路 2,3 的通告</li>
</ul>
<p>設定：<code>router ospf</code> 後 <code>area {number} filter-list prefix {name} {in|out}</code></p>
<ul>
<li>in: 過濾的是建立並洪泛到設定區域(number)的prefix-list(name)</li>
<li>out: 過濾的是從區域(number)離開的prefix-list(name)</li>
</ul>
<p><img src="2019-07-03-16-13-53.png" alt></p>
<h3 id="過濾ospf路徑防止新增到路由表">過濾OSPF路徑防止新增到路由表</h3>
<p>如果同一個區域中有20台路由器，只想在其中5台路由器中過濾路徑，就無法使用過濾第三型 LSA，因為過濾第三型 LSA 只能防止該 LSA 洪泛到整個區域。</p>
<p>利用 <code>distribute-list prefix {name} {in|out}</code> 讓個別的路由器過濾特定的 OSPF 路徑，防止將某條 SPF 計算完後的路徑加入到路由表中。</p>
<p><img src="2019-07-03-16-41-47.png" alt></p>
<ul>
<li><mark>只有 <code>in</code> 可以達到過濾路徑的效用</mark></li>
<li>設定必須參找到 ACL，只有符合 permit 才會被加到路由表</li>
</ul>
<p>檢查：</p>
<ul>
<li><code>show ip route ospf | include {ip}</code></li>
<li><code>show ip ospf database | include {ip}</code></li>
</ul>
<h2 id="路徑彙整">路徑彙整</h2>
<p>目的：減輕路由協定和封包轉送的負擔</p>
<ul>
<li>OSPF 僅支援在 ABR 和 ASBR 做路徑彙整
<ul>
<li>因為區域內的所有路由器都有相同的 LSDB，如果有彙整的需求，應該在區域邊界做彙整，之後洪泛至區域內所有的路由器</li>
</ul>
</li>
<li>想在相同區域的某些路由器彙整特定路徑，無法使用 OSPF 達到</li>
</ul>
<h3 id="abr的手動彙整">ABR的手動彙整</h3>
<p>若區域內的子網路編號正好在同一範圍內，且沒有一個子網路是出現在其他 OSPF 區域裡，在連接該區域的 ABR 上便適合建立路徑彙整。</p>
<p><code>area {area-id} range {ip-address} {mask} [cost {cost}]</code></p>
<ul>
<li><code>area-id</code> 為該子網路所在的區域，<mark>彙整路徑會被通告到其他所有連結 ABR 的路由器</mark></li>
<li>ABR 會比較彙整路徑與所有來源區域內的 OSPF 路徑，如果至少存在一個位於彙整路徑範圍的子網路(<strong>次級子網路</strong>)，則 ABR 會通告此彙整路徑的第三型 LSA
<ul>
<li>ABR 不會通告次級子網路的 LSA</li>
<li>次級子網路如果不存在則不會通告此彙整路徑</li>
</ul>
</li>
<li>ABR 預設會將所有次級子網路的<mark>最佳權值</mark>指派給彙整路徑的第三型 LSA 權值(因為封包到 ABR 後會走最佳路徑)
<ul>
<li><code>area range</code> 的指令也可明確指定權值</li>
</ul>
</li>
</ul>
<p><img src="2019-07-03-17-20-34.png" alt></p>
<p>可以設定 ABR R1 與 R2 將 10.16.1.0/24、10.16.2.0/24、10.16.3.0/24 彙整成 10.16.0.0/22。並使用 <code>area 0 range 10.16.0.0 255.255.252.0</code> 來通告此彙整路徑。</p>
<h3 id="asbr的手動彙整">ASBR的手動彙整</h3>
<p>ASBR 替每個重分配的子網路建立第五型 LSA，並在 LSA 裡將子網路編號列為 LSID，及遮罩列為欄位之一。第五型 LSA 的運作方式與第三型 LSA 運作方式非常類似。</p>
<p><code>summary-address {prefix mask}</code></p>
<ul>
<li>建立第五型 LSA 彙整外部路徑，取代次級子網路的第五型 LSA。如果有任何次級子網路存在，則 ASBR 會執行路徑彙整。</li>
<li>與 ABR 手動彙整的差異：<mark>無法手動設定彙整路徑的權值</mark></li>
</ul>
<h2 id="預設路徑">預設路徑</h2>
<p>使用情境：</p>
<ul>
<li>讓網路邊緣的所有封包傳送到網路核心，因為核心路由器知道更確切的目的地位置</li>
<li>為所有目的地為 Internet 的流量，最終都導向連接 Internet 的路由器</li>
</ul>
<p><img src="2019-07-03-18-20-52.png" alt></p>
<p>ASBR 彙整右方 BGP 學習到的路徑，並將路徑彙整為 0.0.0.0/0，洪泛第五型 LSA 到整個區域中。</p>
<blockquote>
<p>換句話說，當封包目的為 Internet，所有 OSPF 路由器都會選擇預設路徑，將封包傳給 ASBR，再傳送到 Internet 中。</p>
</blockquote>
<p>兩種實現方式：</p>
<ul>
<li>ABR可以使用 <code>area range</code> 將預設路徑洪泛到同一區域中
<ul>
<li>以上圖為例，在 ABR1 上下 <code>area 0 range 0.0.0.0 0.0.0.0</code> 會通告預設路徑到區域1內，且不會通告任何其他從區域0學習到的第三型 LSA</li>
<li>對於封包要前往未知的目的地位址，區域1內的路由器都會使用預設路徑往 ABR，ABR 再決定接下來的路徑</li>
</ul>
</li>
<li>除了 <code>area range</code> 與 <code>summary-address</code>，通常工程師會使用 <code>default-information originate</code> 將預設路徑洪泛到整個 OSPF 領域</li>
</ul>
<h3 id="default-information-originate">default-information originate</h3>
<p>用來告訴 OSPF 去建立預設路徑的<mark>第五型 LSA (用於通告外部路徑)</mark>，換句話說，這個第五型 LSA 會包含預設路徑 (0.0.0.0/0) 的資訊，並洪泛到整個 OSPF 領域，讓所有的路由器都學到了預設路徑</p>
<p><img src="2019-07-03-21-27-24.png" alt></p>
<p>舉例來說，工程師想要使用預設路徑，讓所有路由器傳送封包到 ASBR1 或 ASBR2</p>
<blockquote>
<p>前提是 ASBR 的路由表中已經有存在一條預設路徑(靜態路由/從ISP學到的)</p>
</blockquote>
<ul>
<li>當所有路由器運作正常，路由器會通過 ASBR2 將流量轉送到 Internet (權值較小)</li>
<li>當 ISP1 不再以 BGP 通告預設路徑，或是 ASBR2 與 ISP1 間的 BGP 出現問題，那麼 ASBR2 會移除它的預設路徑，讓 ASBR1 成為 OSPF 領域中的預設路徑 (原先為備援路徑)</li>
</ul>
<p><code>default-information originate [always] [metric metric-value] [metric-type type-value] [route-map map-name]</code></p>
<ul>
<li>使用預設參數，且路由表存在預設路徑，OSPF 會通告 External 第二型的預設路徑(權值為1的第五型LSA)至 OSPF 網路中</li>
<li><code>always</code>：即使路由表不存在預設路徑，仍會通告預設路徑</li>
<li><code>metric</code>：定義預設路徑的權值(預設1)</li>
<li><code>metric-type</code>：LSA 為 External 第一型或 External 第二型(預設為第二型)</li>
<li><code>route-map</code>：根據符合 route map 參照的允許動作，來決定何時通告預設路徑何時移除預設路徑</li>
</ul>
<h3 id="末梢型區域">末梢型區域</h3>
<p><mark>使用預設路徑將末梢區域往未知目的地的封包都轉送到 ABR</mark>，因為 LSDB 裡有的 LSA 較少，因此使用預設路徑可以減少記憶體、CPU消耗。</p>
<p>4種類型：</p>
<ul>
<li>末梢 (stub)</li>
<li>完全末梢 (totally stub)</li>
<li>半末梢 (not-so-stubby areas, NSSA)</li>
<li>完全半末梢 (totally NSSA)</li>
</ul>
<p>細節：</p>
<ul>
<li>4種類型都會過濾第五型LSA</li>
<li>對於名稱有「完全」的種類，還會再過濾第三型LSA</li>
<li>NSSA 可以將外部路徑重分配到區域裡</li>
</ul>
<h4 id="設定-v2">設定</h4>
<p>末梢：區域中的每台路由器都要設定 <code>area {area-id} stub</code></p>
<p>完全末梢：ABR需要設定 <code>area {area-id} stub no-summary</code>，區域中的其他路由器必須設定 <code>area {area-id} stub</code></p>
<p>配置權值：<code>area {area-id} default-cost {metric}</code>，預設為1</p>
<h4 id="檢驗-v2">檢驗</h4>
<p><code>show ip ospf</code>：確認區域為末梢區域</p>
<p><code>show ip ospf database summary 0.0.0.0</code>：列出所有具有 0.0.0.0 的第三型 LSA</p>
<p><code>show ip ospf database database-summary</code>：列出 LSDB 中 LSA 的類型與數量統計，檢查第五型與第三型 LSA 的數量。</p>
<h4 id="例子-v2">例子</h4>
<p><img src="2019-07-05-00-12-20.png" alt="區域34設定為末梢區域"></p>
<ul>
<li>ABR 會過濾掉外部路徑(11.11, 11.12, 11.13)，因此這三條路徑不會出現在區域34的LSDB中</li>
<li>ABR 會通告區域間路徑(10.16.11, 10.16.12, 10.16.13)</li>
</ul>
<p><img src="2019-07-05-00-15-50.png" alt="區域5設定為完全末梢區域"></p>
<ul>
<li>ABR 會過濾掉外部路徑(11.11, 11.12, 11.13)，因此這三條路徑不會出現在區域5的LSDB中</li>
<li>ABR 會過濾掉區域間路徑(10.16.11, 10.16.12, 10.16.13)，因此這三條路徑也不會出現在區域5的LSDB中</li>
</ul>
<h3 id="半末梢區域">半末梢區域</h3>
<p>根據定義可以知道：</p>
<ul>
<li>末梢型區域永遠學不會第五型 LSA</li>
<li>外部路徑加入到 OSPF 會被視為第五型 LSA</li>
</ul>
<p><mark>由此可知 ASBR 無法以正常方式將外部路徑通告到末梢型區域</mark></p>
<p>由於末梢區域不支援第五型 LSA，於是定義了第七型 LSA，第七型 LSA 用途與第五型 LSA 相同，但僅限在 NSSA 中傳送外部路徑。</p>
<p><img src="2019-07-05-00-29-38.png" alt></p>
<ol>
<li>ASBR R3 學到 R9 的外部路徑</li>
<li><code>redistribue</code> 指定路徑重分配，因此從 R9 學到的 EIGRP 路徑會被重分配到 OSPF 中</li>
<li>R3 將第七型 LSA 洪泛到整個 NSSA(區域34)</li>
<li>ABR R1, R2 根據第七型 LSA 建立第五型 LSA，並洪泛第五型 LSA 到其他區域中</li>
</ol>
<h4 id="設定-v3">設定</h4>
<p>NSSA：<code>area {area-id} nssa</code>，ABR 需設定為 <code>area {area-id} nssa default-information-originate</code></p>
<p>完全 NSSA：<code>area {area-id} nssa no-summary</code></p>
<h2 id="ospfv3">OSPFv3</h2>
<p>支援 IPv6</p>
<h3 id="v2-vs-v3">v2 vs v3</h3>
<p>改名的LSA：</p>
<ol>
<li>第三型LSA &gt; ABR的區域間首碼LSA (Interarea prefix LSA for ABR)</li>
<li>第四型LSA &gt; ASBR的區域間首碼LSA (Interarea prefix LSA for ASBR)</li>
</ol>
<p>新的LSA：</p>
<ol>
<li>第八型LSA (Link LSA)，僅存在本地鏈路上，利用它來通告路由器的鏈路區域位址給相同鏈路上的所有其他路由器</li>
<li>第九型LSA (Intra-Area Prefix LSA)，能夠傳遞有關連接路由器的 IPv6 網路資訊 (類似第一型LSA)，此外也能傳送區域內 IPv6 傳輸網路區段的資訊 (類似第二型LSA)</li>
</ol>
<h3 id="ospfv3-傳統設定">OSPFv3 傳統設定</h3>
<ol>
<li>啟用 IPv6 單點傳播路由：<code>ipv6 unicast-routing</code>，或是針對 IPv6 使用 <code>ipv6 cef</code> 啟用 CEF，可以提供更有效的路由查詢</li>
<li><code>ipv6 router ospf {process-id}</code></li>
<li>(Optional) <code>router-id {rid}</code> 設定路由器ID，不設會動態指定一個 IPv4 當作路由器ID</li>
<li><code>ipv6 ospf {process-id} area {area_number}</code> 指定一個以上的介面參與 OSPF</li>
</ol>
<p>檢驗：將檢驗 OSPFv2 的指定中的 <code>ip</code> 換成 <code>ipv6</code></p>
<h3 id="ospfv3-位址家族設定">OSPFv3 位址家族設定</h3>
<p>位址家族 (Address family) 可以在 OSPF 程序下同時支援 IPv4 與 IPv6。有了這個設定，一個 LSDB 即可同時維護 IPv4 與 IPv6 的網路資訊。</p>
<ol>
<li><code>router ospfv3 {process-id}</code></li>
<li>(optional) <code>router-id {rid}</code></li>
<li><code>address-family {ipv4|ipv6}</code></li>
<li>進入希望參與OSPF的介面，<code>ospfv3 {process-id} {ipv4|ipv6} area {area_number}</code></li>
</ol>

</div>


  <div class="book-comments">
    
    <div id="disqus_thread"></div>
    <script>
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://at881005.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



  </div>


<script src="/note/js/book-post.js"></script>
        </div>
      </div>

      <div class="column col-2 hide-lg">
        <div class="book-toc">
  <div class="book-tocbot">
  </div>
  <div class="book-tocbot-menu">
    <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
    <a onclick="go_top()">Back to top</a>
    <a onclick="go_bottom()">Go to bottom</a>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>
      </div>
    </div>
  </div>
</div>

</body>
</html>
