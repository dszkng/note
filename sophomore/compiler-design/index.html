<!DOCTYPE html>
<html lang="">

<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">

    <title>
        
          編譯器設計 - NCTU-Coursenote
        
    </title>

    <!-- Spectre.css framework (v0.5.8) -->
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-exp.min.css">
    <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre-icons.min.css">

    <!-- Noto Sans TC -->
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+TC" rel="stylesheet">

    <!-- theme css & js -->
    <link rel="stylesheet" href="/NCTU-Coursenote/css/spectre_custom.css">
    <link rel="stylesheet" href="/NCTU-Coursenote/css/book.css">
    <script src="/NCTU-Coursenote/js/book.js"></script>

    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- lightgallery.js -->
    
      <script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js"></script>
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
</head>

<body>

<div class="container">
  <div class="book-container">
    <div class="columns">
      
      <div class="column col-2 book-nav">
        <h4 class="site-meta">
    <a href="/NCTU-Coursenote/">NCTU-Coursenote</a>
</h4>



<div class="sidebar-content">
    
        
            <ul class="book-nav-book"><li><span>大一</span></li></ul>
        
            <ul class="book-nav-book"><li><span>大二</span><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/intro-to-formal-language">正規語言概論</a></li></ul><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/intro-to-dbms">資料庫系統概論</a></li></ul><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/computer-organization">計算機組織</a></li></ul><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/signals-and-systems">訊號與系統</a></li></ul><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/intro-to-music-theory">音樂理論導論</a></li></ul><ul class="book-nav-book"><li><a href="/NCTU-Coursenote/sophomore/compiler-design">編譯器設計</a></li></ul></li></ul>
        
            <ul class="book-nav-book"><li><span>大三</span></li></ul>
        
            <ul class="book-nav-book"><li><span>大四</span></li></ul>
        
    
</div>

<script>
document.querySelectorAll('.sidebar-content a').forEach(function(item){ 
    if(item.href === window.location.href || item.href === window.location.href.slice(0, -1)) {
        item.className = "book-nav-current"
    }
})
</script>
      </div>

      <div class="column col-10">
        <div class="book-content">
          <div class="columns">
  <div class="column col-10">
    <div class="book-post">
      <h1 id="編譯器設計">編譯器設計</h1>
<h2 id="課程資訊">課程資訊</h2>
<p>課程名稱：編譯器設計 (Complier Design)</p>
<p>授課教師：游逸平</p>
<p>開課單位：資科工碩</p>
<p>教科書：Compilers: Principles, Techniques, and Tools (2nd edition) <strong>（aka. 龍書）</strong></p>
<p>課程網站：<a href="https://people.cs.nctu.edu.tw/~ypyou/courses/Compiler-grad-s19/" target="_blank" rel="noopener">https://people.cs.nctu.edu.tw/~ypyou/courses/Compiler-grad-s19/</a></p>
<h2 id="introduction">Introduction</h2>
<h3 id="overview">Overview</h3>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-54-12.png">
  <figcaption>
      <p>High-level View of a Compiler</p>
  </figcaption>
</figure>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-54-45.png">
  <figcaption>
      <p>Two-pass Compiler</p>
  </figcaption>
</figure>
<ul>
<li>Use an <strong>intermediate representation</strong> (IR)
<ul>
<li>Reuse components</li>
</ul>
</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-55-09.png" alt></p>
<h3 id="steps-for-generating-an-executable-program">Steps for Generating an Executable Program</h3>
<p>a.c <strong>—COMPILER—&gt;</strong> a.s —ASSEMBLER—&gt; a.o —LINKER—&gt; a.out/a.exe —LOADER—&gt; execution</p>
<h3 id="the-structure-of-a-compiler">The Structure of a Compiler</h3>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-55-32.png" alt></p>
<ul>
<li>Symbol table
<ul>
<li>A data structure containing a record for each <strong>identifier</strong>, with fields for the <strong>attributes</strong></li>
<li>identifier
<ul>
<li>lexical analysis</li>
</ul>
</li>
<li>attributes
<ul>
<li>syntax analysis</li>
<li>semantic analysis</li>
</ul>
</li>
</ul>
</li>
<li>Error Handler</li>
</ul>
<h3 id="lexical-analysis">Lexical Analysis</h3>
<p>divides program text into <strong>“words”</strong> or <strong>“tokens”</strong></p>
<ul>
<li>A stream of tokens</li>
<li>Whitespace and comments are removed</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) a = b;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">lexeme</th>
<th style="text-align:left">if</th>
<th style="text-align:left">(</th>
<th style="text-align:left">b</th>
<th style="text-align:left">==</th>
<th style="text-align:left">0</th>
<th style="text-align:left">)</th>
<th style="text-align:left">a</th>
<th style="text-align:left">=</th>
<th style="text-align:left">b</th>
<th style="text-align:left">;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">token</td>
<td style="text-align:left">KWif</td>
<td style="text-align:left">(</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">==</td>
<td style="text-align:left">NUM</td>
<td style="text-align:left">)</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">=</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">SEMI</td>
</tr>
</tbody>
</table>
<h3 id="syntax-analysis-parsing">Syntax Analysis (Parsing)</h3>
<p>understand sentence structures</p>
<ul>
<li>Abstract syntax tree built from parsing rules</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := b + c * 60</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  :=</span><br><span class="line"> /  \</span><br><span class="line">a    +</span><br><span class="line">    / \</span><br><span class="line">   b   *</span><br><span class="line">      / \</span><br><span class="line">     c   60</span><br></pre></td></tr></table></figure>
<h3 id="semantic-analysis">Semantic Analysis</h3>
<p>try to understand “meaning” (but hard to machine)</p>
<ul>
<li>Compilers perform limited analysis to <strong>catch inconsistencies</strong></li>
<li>Types checked; references to symbols resolved</li>
</ul>
<h3 id="intermediate-code-generation">Intermediate Code Generation</h3>
<p>Constructs <strong>intermediate representations (IRs)</strong> for code optimization</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  :=</span><br><span class="line"> /  \</span><br><span class="line">a    +</span><br><span class="line">    / \</span><br><span class="line">   b   *</span><br><span class="line">      / \</span><br><span class="line">     c   60</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp1 := c * 60</span><br><span class="line">temp2 := b + temp1</span><br><span class="line">a := temp2</span><br></pre></td></tr></table></figure>
<h3 id="code-optimization">Code Optimization</h3>
<p>Automatically modify programs so that they</p>
<ul>
<li>Run faster</li>
<li>Use less memory</li>
<li>Consume lower power</li>
<li>Conserve some resource</li>
</ul>
<h3 id="code-generation">Code Generation</h3>
<p>Produces <strong>assembly code</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp1 := id3 * 60.0</span><br><span class="line">id1 := id2 + temp1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDF R2, id3</span><br><span class="line">MULF R2, R2, #60.0</span><br><span class="line">LDF R1, id2</span><br><span class="line">ADDF R1, R1, R2</span><br><span class="line">STF id1, R1</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="lexical-analysis-v2">Lexical Analysis</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) a = b;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">lexeme</th>
<th style="text-align:left">if</th>
<th style="text-align:left">(</th>
<th style="text-align:left">b</th>
<th style="text-align:left">==</th>
<th style="text-align:left">0</th>
<th style="text-align:left">)</th>
<th style="text-align:left">a</th>
<th style="text-align:left">=</th>
<th style="text-align:left">b</th>
<th style="text-align:left">;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">token</td>
<td style="text-align:left">KWif</td>
<td style="text-align:left">(</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">==</td>
<td style="text-align:left">NUM</td>
<td style="text-align:left">)</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">=</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">SEMI</td>
</tr>
</tbody>
</table>
<ul>
<li>Transform multi-character input stream to token stream</li>
<li>Reduce length of program representation (remove spaces)</li>
</ul>
<h3 id="tokens-patterns-and-lexemes">Tokens, Patterns and Lexemes</h3>
<ul>
<li>Tokens
<ul>
<li>Token is a sequence of characters that can be treated as a single logical entity.</li>
<li>e.g. identifier, keyword, operator</li>
</ul>
</li>
<li>Patterns
<ul>
<li>A set of strings in the <strong>input for which the same token is produced as output</strong>. (<strong>regular expression</strong>)</li>
<li>e.g. [A−Za−z_]</li>
</ul>
</li>
<li>Lexemes (詞位)
<ul>
<li>A lexeme is a sequence of characters in the source program that is <strong>matched by the pattern for a token</strong>.</li>
<li>e.g. x, y; if, else</li>
</ul>
</li>
</ul>
<h3 id="input-buffering">Input Buffering</h3>
<p>Sometimes lexical analyzer needs to <strong>look ahead some symbols</strong> to decide about the token to return.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-, =, &lt; could also beginning of a two-character operator like -&gt;, ==, &lt;-</span><br></pre></td></tr></table></figure>
<h4 id="buffer-pairs">Buffer pairs</h4>
<p>Use <strong>two-buffer scheme</strong> to handle large lookaheads safely.</p>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-56-05.png">
  <figcaption>
      <p>input buffer with buffer pairs</p>
  </figcaption>
</figure>
<ul>
<li>a buffer divided into two N-character halves (e.g. N = 1024)</li>
<li>read N chars into buffer with system read command (v.s. using one system call per character)
<ul>
<li>if fewer than N chars, than marks <strong>eof</strong> at the end of the source file</li>
</ul>
</li>
<li>Two-pointers
<ul>
<li><strong>lexemeBegin</strong> : marks the begining of the current lexeme</li>
<li><strong>forward</strong> : scans ahead until a pattern match is found</li>
</ul>
</li>
</ul>
<blockquote>
<p>lexeme 找到後 lexemeBegin 移至剛剛找到的 lexeme 後方的字元，forward 移至其右端</p>
</blockquote>
<h4 id="sentinels-哨兵">Sentinels (哨兵)</h4>
<p>Without sentinel, we need two tests for out-of-bound for every forward</p>
<ul>
<li>one for the end of the buffer</li>
<li>one to determine what character is read</li>
</ul>
<p>We can combine the buffer-end test with the test for the current character if we <strong>extend each buffer to hold a sentinel character at the end (eof)</strong>.</p>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-57-53.png">
  <figcaption>
      <p>input buffer with sentinels</p>
  </figcaption>
</figure>
<h4 id="comparison">Comparison</h4>
<p>Input buffering with buffer pairs:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Check the end of the buffer</span></span><br><span class="line"><span class="keyword">if</span> (forward at the end of first buffer) &#123;</span><br><span class="line">    reload second buffer</span><br><span class="line">    forward += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (forward at the end of second buffer) &#123;</span><br><span class="line">    reload first buffer</span><br><span class="line">    forward = begin of first buffer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    forward += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. read forward character</span></span><br><span class="line"><span class="keyword">if</span> (*foward == ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Input buffering with sentinels:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">forward += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (*forward == eof) &#123;</span><br><span class="line">    <span class="keyword">if</span> (forward at the end of first buffer) &#123;</span><br><span class="line">        reload second buffer</span><br><span class="line">        forward += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (forward at the end of second buffer)&#123;</span><br><span class="line">        reload first buffer</span><br><span class="line">        forward = begin of first buffer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        terminate lexical analysis</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*forward == ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Visualized detail: <a href="https://www.slideshare.net/dattatraygandhmal/input-buffering" target="_blank" rel="noopener">https://www.slideshare.net/dattatraygandhmal/input-buffering</a></p>
<h3 id="regular-expressions">Regular Expressions</h3>
<p>Use <strong>regular expressions (REs)</strong> to describe programming language tokens</p>
<div>$$
\varnothing : \{\}\\
a : ordinary\,character\\
\varepsilon : empty\,string\\
R|S : R\,or\,S\\
RS : R\,followed\,by\,S\\
R* : concatenation\,of\,R\,zero\,or\,more\,time
$$</div>
<h4 id="language">Language</h4>
<p>A regular expression R describes a <strong>set of strings</strong> of characters denoted <strong>L(R)</strong>, also called a <strong>regular set</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Regular Expression, R</th>
<th style="text-align:left">Strings in L(R)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">“a”</td>
</tr>
<tr>
<td style="text-align:left">ab</td>
<td style="text-align:left">“ab”</td>
</tr>
<tr>
<td style="text-align:left">a|b</td>
<td style="text-align:left">“a”, “b”</td>
</tr>
<tr>
<td style="text-align:left">(ab)*</td>
<td style="text-align:left">“”, “ab”, “abab”, …</td>
</tr>
<tr>
<td style="text-align:left">(a|ε)b</td>
<td style="text-align:left">“ab”, “b”</td>
</tr>
</tbody>
</table>
<p>Suppose <strong>r</strong> and <strong>s</strong> are RE denoting <strong>L(r)</strong> and <strong>L(s)</strong></p>
<ul>
<li>(r) is a RE denoting L(r)</li>
<li>(r)|(s) is a RE denoting L(r)∪L(s)</li>
<li>(r)(s) is a RE denoting L(r)L(s)</li>
<li>(r) <em>is a RE denoting (L(r))</em></li>
</ul>
<h4 id="algebraic-laws-for-res">Algebraic Laws for REs</h4>
<table>
<thead>
<tr>
<th style="text-align:left">LAW</th>
<th style="text-align:left">DESCRIPTION</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r|s = s|r</td>
<td style="text-align:left">| is commutative</td>
</tr>
<tr>
<td style="text-align:left">r|(s|t) = (r|s)|t</td>
<td style="text-align:left">| is associative</td>
</tr>
<tr>
<td style="text-align:left">r(st) = (rs)t</td>
<td style="text-align:left">concatenation is associative</td>
</tr>
<tr>
<td style="text-align:left">r(s|t) = rs|rt; (s|t)r = sr|tr</td>
<td style="text-align:left">concatenation distributes over |</td>
</tr>
<tr>
<td style="text-align:left">εr = rε = r</td>
<td style="text-align:left">ε is the identity for concatenation</td>
</tr>
<tr>
<td style="text-align:left">r* = (r|ε)</td>
<td style="text-align:left">ε is contained in *</td>
</tr>
<tr>
<td style="text-align:left">r** = r</td>
<td style="text-align:left">* is idempotent (冪等)</td>
</tr>
</tbody>
</table>
<h4 id="extensions-of-res">Extensions of REs</h4>
<table>
<thead>
<tr>
<th style="text-align:left">REs</th>
<th style="text-align:left">DESCRIPTION</th>
<th style="text-align:left">ALIAS</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">R+</td>
<td style="text-align:left">one or more strings of R</td>
<td style="text-align:left">R(R*)</td>
</tr>
<tr>
<td style="text-align:left">R?</td>
<td style="text-align:left">optional R</td>
<td style="text-align:left">R|ε</td>
</tr>
<tr>
<td style="text-align:left">[abcd]</td>
<td style="text-align:left">one of listed characters</td>
<td style="text-align:left">(a|b|c|d)</td>
</tr>
<tr>
<td style="text-align:left">[a-z]</td>
<td style="text-align:left">one character from this range</td>
<td style="text-align:left">(a|b|c|d…|z)</td>
</tr>
<tr>
<td style="text-align:left">[^ab]</td>
<td style="text-align:left">anything but one of the listed chars</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">[^a-z]</td>
<td style="text-align:left">one character not from this range</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="regular-definitions">Regular Definitions</h4>
<p>give <strong>names</strong> to regular expressions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name -&gt; regular expression</span><br><span class="line">d1 -&gt; r1</span><br><span class="line">d2 -&gt; r2</span><br><span class="line">...</span><br><span class="line">dn -&gt; rn</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.g. digit = [0-9], posint = digit+</span><br></pre></td></tr></table></figure>
<h4 id="restrictions-on-res">Restrictions on REs</h4>
<p>Regular expressions are not capable of describing most complete languages.</p>
<p>They describe languages composed of sets of strings of the form :</p>
<div>$$
S\to\alpha B\\
where\\
\alpha \in basic\,symbol\\
B\,is\,a\,regular\,definition\\
S\,is\,a\,regular\,definition\,and\,is\,not\,part\,of\,B\\
$$</div>
<p>They <strong>cannot</strong> describe:</p>
<ul>
<li>Balanced nesting constructs
<ul>
<li>e.g.  if … then … else …</li>
</ul>
</li>
<li>Repetition of the same string
<ul>
<li>e.g.  {wcw | w is a string of a’s and b’s}</li>
</ul>
</li>
<li>Constructs where the number of repetitions is fixed by the value of a part of the string
<ul>
<li>e.g.  nHa1a2 …an</li>
</ul>
</li>
</ul>
<p>Anything that needs to “<strong>memorize</strong>” “<strong>non-constant</strong>” amount of information <strong>happened in the past</strong> cannot be recognized by regular expressions</p>
<h4 id="chomsky-hierarchy">Chomsky Hierarchy</h4>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-58-21.png" alt></p>
<ul>
<li>Unrestricted languages (type 0)
<ul>
<li>Turing machines</li>
</ul>
</li>
<li>Context-sensitive languages (type 1)
<ul>
<li>Linear bounded automata</li>
</ul>
</li>
<li>Context-free languages (type 2)
<ul>
<li>Pushdown automata</li>
</ul>
</li>
<li>Regular languages (type 3)
<ul>
<li>Finite automata</li>
</ul>
</li>
</ul>
<h3 id="interaction-between-scanner-parser">Interaction between Scanner &amp; Parser</h3>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-58-51.png" alt></p>
<p><strong>Attributes of Tokens</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">Lexemes</th>
<th style="text-align:left">Token Name</th>
<th style="text-align:left">Attribute Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">if</td>
<td style="text-align:left">if</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">then</td>
<td style="text-align:left">then</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">else</td>
<td style="text-align:left">else</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">id</td>
<td style="text-align:left">id</td>
<td style="text-align:left">Pointer to table entry</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">number</td>
<td style="text-align:left">Pointer to table entry (or the value of the number)</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">LT</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">LE</td>
</tr>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">EQ</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">NE</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">GT</td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">relop</td>
<td style="text-align:left">GE</td>
</tr>
</tbody>
</table>
<h3 id="implementation-of-lexical-analysis">Implementation of Lexical Analysis</h3>
<p>Use <strong>Transition Diagram</strong></p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-59-17.png" alt></p>
<p><strong>Recognizes reserved words</strong></p>
<p>problem: keyword maybe recognize as an identifier</p>
<p>Two solutions:</p>
<ul>
<li>Install the reserved words in the symbol table initially
<ul>
<li>installID() : place identifier in the symbol table if it is <strong>not already there</strong>, and return a pointer to the symbol-table entry for the lexeme found</li>
<li>getToken() : return token name (either <strong>id</strong> or one of the <strong>keyword</strong> tokens that was initially installed in the table)</li>
</ul>
</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-59-35.png" alt></p>
<ul>
<li>Create separate transition diagrams for each keyword</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-01-59-51.png" alt></p>
<h3 id="finite-automata">Finite Automata</h3>
<p>Recognizers which simply say “<strong>yes</strong>” or “<strong>no</strong>” about each possible input string</p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-02-00-18.png" alt></p>
<p><strong>Definition</strong></p>
<div>$$
M = (S, \Sigma, S_0, F, T)\\
S : all\,state\,in\,the\,FA\\
\Sigma : all\,simbols\,accepted\,by\,the\,language\\
S_0 : Start\,state\\
F : Accepting\,states\\
T : All\,transitions
$$</div>
<p><strong>Epsilon Moves</strong></p>
<p>Machine can move from state A to state B without reading input</p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-02-00-32.png" alt></p>
<p><strong>Nondeterministic Finite Automata (NFA)</strong></p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-02-00-46.png" alt></p>
<ul>
<li>Can have multiple transitions for one input in a given state</li>
<li>Can have ε-moves</li>
</ul>
<p><strong>Deterministic Finite Automata (DFA)</strong></p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-02-01-06.png" alt></p>
<ul>
<li>One transition per input per state</li>
<li>No ε-moves</li>
</ul>
<p><strong>NFA vs DFA</strong></p>
<ul>
<li>DFA
<ul>
<li>Action on each input is fully determined</li>
<li>Easier to implement</li>
</ul>
</li>
<li>NFA
<ul>
<li>May have choices at each step</li>
<li>Accepts string if there is <strong>ANY path to an accepting state</strong></li>
<li>More complex in implementation
<ul>
<li>May need to backtrack</li>
<li>May end up exploring all the paths in the NFA</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Transition Table</strong></p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-02-01-40.png" alt></p>
<table>
<thead>
<tr>
<th style="text-align:left">State</th>
<th style="text-align:left">a</th>
<th style="text-align:left">b</th>
<th style="text-align:left">ε</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">{0, 1}</td>
<td style="text-align:left">{0}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">{2}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">{3}</td>
<td style="text-align:left">∅</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">∅</td>
<td style="text-align:left">∅</td>
</tr>
</tbody>
</table>
<ul>
<li>Columns are input symbols</li>
<li>Rows are current states</li>
<li>Entries are resulting states</li>
<li>Pros and Cons
<ul>
<li>Pro
<ul>
<li>easily find the transitions</li>
</ul>
</li>
<li>Con
<ul>
<li>take lots of space</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="re-to-automata">RE to Automata</h3>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-09-18.png" alt></p>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-06-45.png">
  <figcaption>
      <p>High-level sketch</p>
  </figcaption>
</figure>
<h4 id="thompson-s-construction">Thompson’s construction</h4>
<div>$$
Regular\,Expression\xrightarrow{\text{Thompson's Construction}}NFA
$$</div>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-19-26.png">
  <figcaption>
      <p>For expression ε</p>
  </figcaption>
</figure>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-19-41.png">
  <figcaption>
      <p>For any subexpression a in Σ</p>
  </figcaption>
</figure>
<p>Suppose N(s) and N(t) are NFA’s for RE s and t</p>
<ul>
<li>r = s|t</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-22-41.png">
  <figcaption>
      <p>Alternation</p>
  </figcaption>
</figure>
<ul>
<li>r = st</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-25-48.png">
  <figcaption>
      <p>Concatenation</p>
  </figcaption>
</figure>
<ul>
<li>r = s*</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-26-22.png">
  <figcaption>
      <p>Kleene closure</p>
  </figcaption>
</figure>
<ul>
<li>Precedence of Operators
<ol>
<li>Kleene closure (*), ?, +</li>
<li>concatenation</li>
<li>alternation</li>
</ol>
</li>
<li>All operators are <strong>left associative</strong></li>
</ul>
<h4 id="subset-construction">Subset Construction</h4>
<div>$$
NFA\xrightarrow{\text{Subset Construction}}DFA
$$</div>
<ul>
<li>remove ε-transitions to get a DFA</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-13-12-47-26.png" alt></p>
<h4 id="operations-on-nfa-states">Operations on NFA States</h4>
<ul>
<li>ε-closure(s)
<ul>
<li>s 可以透過 ε-transition 到達的 NFA state 的 set</li>
</ul>
</li>
<li>ε-closure(T)
<ul>
<li>在 set T 裡面的 NFA state s 可以透過 ε-transition 到達的 NFA state 的 set</li>
</ul>
</li>
<li>move(T, a)
<ul>
<li>在 set T 裡面的 NFA state s 可以透過 input symbol a 到達的 NFA state 的 set</li>
</ul>
</li>
</ul>
<h4 id="converting-nfa-to-dfa">Converting NFA to DFA</h4>
<ul>
<li>Construct the initial state of the DFA
<ul>
<li>finding <strong>ε-closure(s0)</strong></li>
</ul>
</li>
<li>From a state <em><strong>T</strong></em> in the DFA, for each input character <em><strong>a</strong></em>
<ul>
<li>finding <strong>ε-closure( move(T, a) )</strong>, say U</li>
<li>make U a state in DFA if it is not there yet
<ul>
<li>if U contains at least one final state in NFA, then mark it as a final state in DFA</li>
</ul>
</li>
<li>make <strong>T x a -&gt; U</strong> a transition in DFA</li>
</ul>
</li>
<li>Repeat the step above for all states in DFA that has not been processed yet</li>
</ul>
<h4 id="minimized-dfa">Minimized DFA</h4>
<p>同個 language 可以用不同的 DFA 來表示，所以我們可以找到最少 state 的 DFA 來優化從 NFA 轉過來的 DFA。</p>
<p><strong>key principle : merge 有相同行為的 state</strong></p>
<ul>
<li>final states 與 non-final states 不可 merge</li>
<li>對所有 x 從 state s 到 t，若所有 acceptance decision 相同，則 s 與 t 有相同的行為</li>
</ul>
<p>流程：</p>
<ul>
<li>初始化
<ul>
<li>將 final state 與 non-final state 區格開</li>
</ul>
</li>
<li>區分不同的群組 G
<ul>
<li>對所有 input symbol a，在 G 中的兩個 state s 與 t 可以通過 a 轉到相同的群組，則 s 與 t 屬於同一個群組</li>
<li>除此之外，將 s 與 t 放至不同群組中</li>
</ul>
</li>
<li>重複直到群組不再變化</li>
</ul>
<p>例子：</p>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-13-33-06.png">
  <figcaption>
      <p>before minimize</p>
  </figcaption>
</figure>
<ul>
<li>
<p>Final-state: {E}</p>
<p>Non-final-state: {A, B, C, D}</p>
</li>
<li>
<p>Try to split {A,B,C,D}</p>
<ul>
<li>for input a
<ul>
<li>A,B,C,D all go to {A,B,C,D} on a</li>
</ul>
</li>
<li>for input b
<ul>
<li>A,B,C go to {A,B,C,D} on b</li>
<li>D goes to {E} on b</li>
</ul>
</li>
<li>{A,B,C,D} → {A,B,C},{D},{E}</li>
</ul>
</li>
<li>
<p>Try to split {A,B,C}</p>
<ul>
<li>for input a
<ul>
<li>A,B,C all go to {A,B,C} on a</li>
</ul>
</li>
<li>for input b
<ul>
<li>A,C go to {A,B,C} on b</li>
<li>B goes to {D} on b</li>
</ul>
</li>
<li>{A,B,C},{D},{E} → {A,C},{B},{D},{E}</li>
</ul>
</li>
<li>
<p>A,C go to the same states on each input</p>
</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-13-31-33.png">
  <figcaption>
      <p>after minimize</p>
  </figcaption>
</figure>
<h3 id="implementation-of-lexical-analyzer-generator">Implementation of Lexical Analyzer Generator</h3>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-13-45-10.png">
  <figcaption>
      <p>The structure of the generated analyzer</p>
  </figcaption>
</figure>
<h4 id="ambiguity-resolution">Ambiguity Resolution</h4>
<h5 id="longest-match">Longest match</h5>
<ul>
<li>match 最長的 pattern</li>
<li>在 accept 前需要 lookahead</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-14-00-14.png">
  <figcaption>
      <p>input: abbbbccd&#xFF0C;&#x82E5; abbbb &#x5F8C;&#x662F; ccd &#x5247; accept state 6&#xFF0C;&#x5426;&#x5247; accept state 3</p>
  </figcaption>
</figure>
<h5 id="first-match">First match</h5>
<ul>
<li>conflict 時選最先列出的 rule</li>
</ul>
<h5 id="lookahead">Lookahead</h5>
<p>有些情形 longest match 和 first match 無法處理</p>
<blockquote>
<p>e.g. In fortran:</p>
<p>treat IF a keyword: IF (a = b) THEN …<br>
treat IF a identifier: IF (I, J) = 3 …</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IF / \( .* \) letter &#123;return IF&#125;</span><br><span class="line">Otherwise, return identifier</span><br></pre></td></tr></table></figure>
<p>/ 後方可以 match additional pattern 但是不 match lexeme，所以下次的 match 是從 ( 開始，而不是 letter 後方</p>
<h4 id="lexical-analyzer-generator-lex">Lexical Analyzer Generator: Lex</h4>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-14-31-53.png">
  <figcaption>
      <p>How Does Lex Work?</p>
  </figcaption>
</figure>
<p>當 RE 能有多個 match 情形時，考慮：</p>
<ul>
<li>Longest matching token</li>
<li>Token specification order</li>
</ul>
<hr>
<h2 id="syntax-analysis">Syntax Analysis</h2>
<p><strong>Goal – 判斷 input token stream 是否滿足程式語言的 syntax</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (b == 0) a = b;</span><br></pre></td></tr></table></figure>
<p>Lexical Analyzer or Scanner:</p>
<table>
<thead>
<tr>
<th style="text-align:left">lexeme</th>
<th style="text-align:left">if</th>
<th style="text-align:left">(</th>
<th style="text-align:left">b</th>
<th style="text-align:left">==</th>
<th style="text-align:left">0</th>
<th style="text-align:left">)</th>
<th style="text-align:left">a</th>
<th style="text-align:left">=</th>
<th style="text-align:left">b</th>
<th style="text-align:left">;</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">token</td>
<td style="text-align:left">KWif</td>
<td style="text-align:left">(</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">==</td>
<td style="text-align:left">NUM</td>
<td style="text-align:left">)</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">=</td>
<td style="text-align:left">ID</td>
<td style="text-align:left">SEMI</td>
</tr>
</tbody>
</table>
<p>Syntax Analyzer or Parser:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     if</span><br><span class="line">    /  \</span><br><span class="line">  ==     =</span><br><span class="line"> / \    / \</span><br><span class="line">b   0  a   b</span><br></pre></td></tr></table></figure>
<p>速成 Syntax Analysis: <a href="https://www.youtube.com/watch?v=uPnpkWwO9hE&amp;list=PLW1OMpQZxu7xMh7nuDQYQ2mDcqY2hzBWk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=uPnpkWwO9hE&amp;list=PLW1OMpQZxu7xMh7nuDQYQ2mDcqY2hzBWk</a></p>
<h3 id="syntax-error-recovery-strategies">Syntax Error-Recovery Strategies</h3>
<ul>
<li>Panic-mode Recovery (simple)
<ul>
<li>忽略 input symbols 直到找到 synchronizing tokens (通常是 delimiter)</li>
</ul>
</li>
<li>Phrase-level Recovery
<ul>
<li>局部修正錯誤</li>
<li>e.g. comma → semicolon, insert/delete semicolon</li>
</ul>
</li>
<li>Error-productions
<ul>
<li>將可能的 error 情形寫成 productions 加到 grammar 中</li>
<li>產生對應的 error diagnostics</li>
</ul>
</li>
<li>Global-correction (theoretical)
<ul>
<li>選擇需要 cost 最小的地方做修正</li>
</ul>
</li>
</ul>
<h3 id="context-free-grammars">Context-Free Grammars</h3>
<div>$$
G = (T, N, S, P)\\
T: terminals = token\,or\,\varepsilon\\
N: nonterminals = syntactic\,variables\\
S: start\,symbol = special\,nonterminal\\
P: productions\,of\,the\,form = head \to body
$$</div>
<p>More on CFGs, see: <a href="https://kaiiiz.github.io/NCTU-Coursenote/sophomore/intro-to-formal-language/">正規語言概論</a></p>
<h3 id="grammar-transformations">Grammar Transformations</h3>
<h4 id="消除-ambiguity">消除 ambiguity</h4>
<blockquote>
<p>有多種 parse trees 的 grammar 稱為 ambiguous grammar</p>
</blockquote>
<p><strong>solution : 重寫 grammar</strong></p>
<p><strong>例子1: 對每個 precedence level 多加一個 nonterminal</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E → E + E | E * E | –E | (E) | id</span><br><span class="line">轉為</span><br><span class="line">E → E + E | T</span><br><span class="line">T → T * T | F</span><br><span class="line">F → –E | (E) | id</span><br></pre></td></tr></table></figure>
<p>problem:</p>
<p>無法辨識有結合律的語句 (e.g. id + id + id)</p>
<p>solution:</p>
<p>E → E + E ，因為 + 的兩側都是 E ，需要將 E 轉成另一個 nonterminal 來解決結合律的問題: E → E + T | T</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">E → E + E | T</span><br><span class="line">T → T * T | F</span><br><span class="line">F → –E | (E) | id</span><br><span class="line">轉為</span><br><span class="line">E → E + T | T</span><br><span class="line">T → T * T | F</span><br><span class="line">F → –E | (E) | id</span><br></pre></td></tr></table></figure>
<p><strong>例子2: if 的巢狀結構</strong> (重寫 grammar 有時可能需要對某些情形做特判)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stmt → if-stmt | while-stmt | ...</span><br><span class="line">if-stmt → if expr then stmt else stmt | if expr then stmt</span><br></pre></td></tr></table></figure>
<ul>
<li>input: if (a) then if (b) then x = c else x = d</li>
<li>ambiguity:
<ul>
<li>if (a) then {if (b) then x = c} else x = d</li>
<li>if (a) then {if (b) then x = c else x = d}</li>
</ul>
</li>
</ul>
<p>solution:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if-stmt → unmatched-stmt | matched-stmt</span><br><span class="line">matched-stmt → if expr then matched-stmt else matched-stmt | others</span><br><span class="line">unmatched-stmt → if expr then matched-stmt else unmatched-stmt</span><br><span class="line">unmatched-stmt → if expr then if-stmt</span><br></pre></td></tr></table></figure>
<p>一旦進入 matched-stmt 就無法再回到 unmatched-stmt</p>
<h4 id="消除-left-recursion">消除 left recursion</h4>
<blockquote>
<p>A grammar is left recursive if it has a nonterminal <code>$A$</code> such that there’s a derivation <code>$A \overset{+}{\Rightarrow} A \alpha$</code> a for some string <code>$\alpha$</code></p>
</blockquote>
<p>Top-down parsing 無法處理 left-recursive grammars</p>
<p>solution:</p>
<p>由 <code>$A \rightarrow A \alpha \, | \, \beta$</code> 轉為 <code>$A \rightarrow \beta A'$</code>、<code>$A' \rightarrow \alpha A’ | \varepsilon$</code></p>
<blockquote>
<p>In general:</p>
<div>$$
A \to A \alpha_1| A \alpha_2 | ...|A \alpha_m | \beta_1 | \beta_2 | ... | \beta_n\\
\downarrow\\
A \to \beta_1 A' | \beta_2 A' | ... | \beta_n A'\\
A' \to \alpha_1 A' | \alpha_2 A' | ... | \alpha_m A' | \varepsilon
$$</div>
</blockquote>
<p>problem:</p>
<p>不能消除需要多次轉換才出現的 left-recursive</p>
<blockquote>
<p>e.g.</p>
<div>$$
S \to Aa \, | \, b\\
A \to Ac \, | \, Sd \, | \, \varepsilon\\
\downarrow\\
S \Rightarrow Aa \Rightarrow Sda
$$</div>
</blockquote>
<p>solution:</p>
<p>假設沒有 <code>$A \overset{+}{\Rightarrow} A$</code> 及 <code>$A \to \varepsilon$</code></p>
<blockquote>
<p>將所有 nonterminal 排序： <code>$A_1, A_2, ..., A_n$</code><br>
for (each i from 1 to n) {<br>
　　for (each j from 1 to i - 1) { // j &lt; i<br>
　　　將 <code>$A_i \to A_j \gamma$</code>、<code>$A_j \to \delta_1 | \delta_2 | ... | \delta_k$</code> 取代成 <code>$A_i \to \delta_1 \gamma | \delta_2 \gamma | ... | \delta_k \gamma$</code><br>
　　}<br>
　　對所有 <code>$A_i$</code> 的 productions 消除 immediate left recursion<br>
}</p>
</blockquote>
<h4 id="left-factoring">Left factoring</h4>
<p>用來產生適合 top-down parsing 的 grammar (predictive)</p>
<p>problem:</p>
<blockquote>
<p><code>$A \to a \beta_1 \, | \, a \beta_2$</code> 在碰到 <code>$a$</code> 後不能馬上確定應該要 derive 成 <code>$a \beta_1$</code> 或是 <code>$a \beta_2$</code></p>
</blockquote>
<p>solution:</p>
<blockquote>
<div>$$
A \to a \beta_1 \, | \, a \beta_2\\
\downarrow\\
A \to a A'\\
A' \to \beta_1 \, | \beta_2
$$</div>
</blockquote>
<h3 id="parser">Parser</h3>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-13-15-43-32.png">
  <figcaption>
      <p>Various kinds: LL(k), LR(k), SLR, LALR</p>
  </figcaption>
</figure>
<h4 id="top-down-parser-ll-parser">Top-down parser (LL parser)</h4>
<ul>
<li>從 root 開始長出 leaves</li>
<li>Left-to-right scan</li>
<li>Leftmost derivation</li>
</ul>
<blockquote>
<p>e.g.</p>
<p>input: id + id</p>
<p><code>$E \to T + T\\T \to E | -E | id$</code></p>
<p>solution:</p>
<p><code>$E \underset{lm}{\Rightarrow} T + T \underset{lm}{\Rightarrow} id + T \underset{lm}{\Rightarrow} id + id$</code></p>
</blockquote>
<h4 id="bottom-up-parser-lr-parser">Bottom-up parser (LR parser)</h4>
<ul>
<li>從 leaves 開始長出 root</li>
<li>Left-to-right scan</li>
<li>Rightmost derivation</li>
</ul>
<h3 id="top-down-parsing">Top-Down Parsing</h3>
<p>從 root 以 preorder 建立 parse tree</p>
<ul>
<li>找 input string 的 leftmost derivation</li>
<li>遞迴尋找 nonterminal 可能的展開，錯誤時需要 backtrack</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-14-17-07-27.png" alt></p>
<p>Predictive Parsing: 藉由 lookahead (k) 個 symbols 直接選擇正確的 production</p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-14-17-14-04.png" alt></p>
<p>lookahead (k) 個 symbols 的 LL parser 稱為 LL(k)</p>
<h4 id="first-and-follow-sets">FIRST and FOLLOW Sets</h4>
<ul>
<li>Sets of terminals</li>
<li>用途：透過下一個 input symbol 選擇要 apply 那個 production</li>
</ul>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-14-17-48-46.png">
  <figcaption>
      <p>c in FIRST(A) and a in FOLLOW(a)</p>
  </figcaption>
</figure>
<h4 id="first-sets">FIRST Sets</h4>
<div>$$
First(\alpha): Set \, of \, terminals \, that \, begin \, strings \,derived \, from \, \alpha \\
\alpha \in terminals \, or \, nonterminals
$$</div>
<blockquote>
<p>if <code>$\alpha \overset{*}{\Rightarrow} c \gamma \,$</code> ,then <code>$c \in FIRST(\alpha)$</code><br>
if <code>$\alpha \overset{*}{\Rightarrow} \varepsilon \,$</code> ,then <code>$\varepsilon \in FIRST(\alpha)$</code></p>
</blockquote>
<h4 id="follow-sets">FOLLOW Sets</h4>
<div>$$Follow(A): Set \, of \, terminals \, \alpha \, that \, can \, appear \, immediately \, to \, the \, right \, of \, A \\
A \in nonterminals
$$</div>
<blockquote>
<p>if <code>$S \overset{*}{\Rightarrow} \alpha A a \beta \,$</code> ,then <code>$a \in FOLLOW(A)$</code><br>
if <code>$A$</code> can be the rightmost symbol in some sentential form, then <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>e</mi><mi>n</mi><mi>d</mi><mi>m</mi><mi>a</mi><mi>r</mi><mi>k</mi><mi>e</mi><mi>r</mi><mo>)</mo><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">(endmarker) `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mord">‘</span></span></span></span>\in FOLLOW(A)$`</p>
</blockquote>
<h4 id="why-first-set">Why FIRST Set?</h4>
<div>$$
A \to \alpha_1 \\
A \to \alpha_2 \\
... \\
A \to \alpha_k
$$</div>
<div>$$
current \, lookahead \, symbol \, is \, \alpha
$$</div>
<ul>
<li>若只有一個 <code>$\alpha \in FIRST(\alpha_i)$</code> 則選 <code>$A \to \alpha_i$</code></li>
<li>若滿足多個 <code>$FIRST(\alpha_i)$</code>，則這個 grammar 不是 LL(1)</li>
</ul>
<h4 id="why-follow-set">Why FOLLOW Set?</h4>
<div>$$
A \to \alpha_1 \\
A \to \alpha_2 \\
... \\
A \to \alpha_k
$$</div>
<div>$$
current \, lookahead \, symbol \, is \, \alpha
$$</div>
<ul>
<li>若只有一個 i 滿足 <code>$\alpha \in FIRST(\alpha_i)$</code> 則選 <code>$A \to \alpha_i$</code></li>
<li>若滿足多個 <code>$FIRST(\alpha_i)$</code>，則這個 grammar 不是 LL(1)</li>
<li>若沒有 i 滿足 <code>$\alpha \in FIRST(\alpha_i)$</code>，這個 grammar 仍為 LL(1)
<ul>
<li>因為若有任何 <code>$\alpha_i \overset{*}{\Rightarrow} \varepsilon$</code> 且 <code>$a \in FOLLOW(A)$</code> 則可以用 <code>$A \to \alpha_i$</code> 將 A 換成 <code>$\varepsilon$</code></li>
</ul>
</li>
</ul>
<h4 id="ll-1-parsing">LL(1) Parsing</h4>
<p>Recursive-Descent Parsing</p>
<p>looking <strong>one</strong> symbols ahead in the input (i.e., current input symbol)</p>
<ul>
<li>LL(1) 不能處理 left-recursive grammars (因為需要 lookahead 多位才知道要不要做 production) (Parsing Tree 會無限往下長)</li>
<li></li>
</ul>
<h5 id="grammar-滿足條件">Grammar 滿足條件</h5>
<p>對 <code>$A \to \alpha | \beta$</code>，LL(1) 需要滿足的條件：</p>
<ol>
<li><code>$\alpha, \beta$</code> 不能 derive 出相同的 first terminal</li>
<li><code>$\alpha, \beta$</code> 只有一個可以 derive 出 <code>$\varepsilon$</code></li>
<li>若 <code>$\beta \overset{*}{\Rightarrow} \epsilon$</code> 則 <code>$\alpha$</code> derive 出的 first terminal 不能包含在 FOLLOW(A) 中 (因為 有兩條路：選 <code>$\beta$</code> + FOLLOW(A) 或 FIRST(<code>$\alpha$</code>))</li>
</ol>
<h5 id="parse-規則">Parse 規則</h5>
<p>假設 <code>$a$</code> 是 current input symbol 或 <code>$\$$</code>(endmarker)</p>
<p>若 <code>$A \to \alpha$</code> 被選擇，需要滿足：</p>
<ul>
<li><code>$a \in FIRST(\alpha)$</code> 或</li>
<li><code>$\varepsilon \in FIRST(A)$</code> 或</li>
<li><code>$a = \$$</code> 且 <code>$\$ \in FOLLOW(A)$</code></li>
</ul>
<h5 id="predictive-parsing-table">Predictive Parsing Table</h5>
<p>M[A, a]: 對 nonterminal A 及 input symbol a 在 parsing table 存在的 production</p>
<p>演算法：</p>
<blockquote>
<p>對所有 <code>$A \to \alpha$</code>：</p>
<ol>
<li>對所有 <code>$a \in FIRST(\alpha)$</code>, 將 <code>$A \to \alpha$</code> 加到 M[A, a]</li>
<li>若 <code>$\varepsilon \in FIRST(\alpha)$</code> 則：</li>
<li>對所有 <code>$b \in FOLLOW(A)$</code>， 將 <code>$A \to \alpha$</code> 加到 M[A, b]</li>
<li>若 <code>$\varepsilon \in FOLLOW(A)$</code>， 將 <code>$A \to \alpha$</code> 加到 M[A, $]</li>
<li>將空的位置設為 error</li>
</ol>
</blockquote>
<p>若 parsing table 中一個 entry 有兩個 production (conflict)，表示這個 grammar 不是 LL(1) 能處理的，可能要考慮 LL(2)、LL(3)…</p>
<h4 id="nonrecursive-predictive-parsing">Nonrecursive Predictive Parsing</h4>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-14-19-56-50.png">
  <figcaption>
      <p>parsing table + stack</p>
  </figcaption>
</figure>
<p>不用 recursive 改用 stack 實做</p>
<h4 id="error-recovery-panic-mode">Error Recovery: Panic mode</h4>
<p>Review: <a href="#syntax-error-recovery-strategies">Syntax Error-Recovery Strategies</a></p>
<p>若 M[A, a] 為空且 <code>$a \in FOLLOW(A)$</code> 則把 M[A, a] 設為 <strong>synch</strong></p>
<p>策略：</p>
<p>另 A = top of stack、a = current input</p>
<ul>
<li>if A == Nonterminal
<ul>
<li>M[A, a] = {empty}: skip a (沒有 production 可做，忽略 input)</li>
<li>M[A, a] = {synch}: pop A (因為 <code>$a \in FOLLOW(A)$</code>，所以先把 A pop 掉，下一 run a 就可以接在 A 後面了)</li>
</ul>
</li>
<li>if A == terminal
<ul>
<li>A != a: pop A</li>
</ul>
</li>
</ul>
<h3 id="bottom-up-parsing">Bottom-Up Parsing</h3>
<p>從 leave 長回 root</p>
<ul>
<li>LR parsing: Left-to-right scan, Rightmost derivation (反向)</li>
<li>過程像是將 input string “reduce” 回 start symbol</li>
</ul>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-14-23-01-01.png" alt></p>
<ul>
<li>Pros
<ul>
<li>比 LL parser 強大，幾乎可以描述所有程式語言</li>
<li>不需要 backtracing</li>
</ul>
</li>
<li>Cons
<ul>
<li>建一個 LR parser 比較貴</li>
</ul>
</li>
</ul>
<h4 id="handle-pruning">Handle Pruning</h4>
<div>$$
S \to aABe\\
A \to Abc | b\\
B \to d
$$</div>
<div>$$
input: abbcde
$$</div>
<table>
<thead>
<tr>
<th>Right Sentential Form</th>
<th>Handle</th>
<th>Viable Prefix</th>
<th>Reducing Production</th>
</tr>
</thead>
<tbody>
<tr>
<td>a<strong>b</strong>bcde</td>
<td>b</td>
<td>ab</td>
<td>A → b</td>
</tr>
<tr>
<td>a<strong>Abc</strong>de</td>
<td>Abc</td>
<td>aAbc</td>
<td>A → Abc</td>
</tr>
<tr>
<td>aA<strong>d</strong>e</td>
<td>d</td>
<td>aAd</td>
<td>B → d</td>
</tr>
<tr>
<td><strong>aABe</strong></td>
<td>aABe</td>
<td>aABe</td>
<td>S → aABe</td>
</tr>
</tbody>
</table>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-14-23-48-24.png">
</figure>
<p>Formally, 若 <code>$S \overset{*}{\underset{rm}{\Rightarrow}} \alpha A w \underset{rm}{\Rightarrow} \alpha \beta w$</code>，則 <code>$\alpha \beta w$</code> 的 <strong>handle</strong>: 在 <code>$\alpha$</code> 後方的位置做 production <code>$A \to \beta$</code></p>
<p><strong>Viable Prefix</strong>: handle 尾巴前的前綴</p>
<p>尋找 handle 並 reduce 它的過程稱作：<strong>Handle Pruning</strong></p>
<h4 id="shift-reduce-parsing">Shift-Reduce Parsing</h4>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-15-00-09-58.png">
  <figcaption>
      <p>Performs handle pruning with a stack</p>
  </figcaption>
</figure>
<ul>
<li>用 stack 持續觀察看到的 input</li>
<li>在 stack 中的 elements 一定是 viable prefix</li>
<li>4 actions
<ul>
<li>Shift: 將下一個 token 丟到 stack</li>
<li>Reduce: Handle 的最右端在 stack 的 top，尋找 handle 的左端並 reduce 之</li>
<li>Accept: parse 成功</li>
<li>Error: call error reporting/recovery</li>
</ul>
</li>
</ul>
<div>$$
E \to E + T | T\\
T \to T * F | F\\
F \to (E) | id
$$</div>
<div>$$
input: id*id
$$</div>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Input</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>$</td>
<td>id * id$</td>
<td>shift</td>
</tr>
<tr>
<td>$id</td>
<td>* id$</td>
<td>reduce by <code>$F \to id$</code></td>
</tr>
<tr>
<td>$F</td>
<td>* id$</td>
<td>reduce by <code>$T \to F$</code></td>
</tr>
<tr>
<td>$T</td>
<td>* id$</td>
<td>shift</td>
</tr>
<tr>
<td>$T *</td>
<td>id$</td>
<td>shift</td>
</tr>
<tr>
<td>$T * id</td>
<td>$</td>
<td>reduce by <code>$F \to id$</code></td>
</tr>
<tr>
<td>$T * F</td>
<td>$</td>
<td>reduce by <code>$T \to T * F$</code></td>
</tr>
<tr>
<td>$T</td>
<td>$</td>
<td>reduce by <code>$E \to T$</code></td>
</tr>
<tr>
<td>$E</td>
<td>$</td>
<td>accept</td>
</tr>
</tbody>
</table>
<p>Compare: <a href="#lr-0-parsing">LR(0) Parsing</a></p>
<h5 id="issue">Issue</h5>
<p>不確定什麼時候要 reduce 什麼時候要 shift</p>
<ul>
<li>有時不可 reduce</li>
<li>有時可以 reduce 也可以 shift</li>
<li>有時有多種 reduce 的方式</li>
</ul>
<h5 id="solution">Solution</h5>
<ul>
<li>做一張認得所有 viable prefiexes 的 DFA</li>
<li>用 stack 持續觀察看到的 input 決定下一個 state</li>
</ul>
<h4 id="lr-0-automaton">LR(0) Automaton</h4>
<h5 id="definition">Definition</h5>
<ul>
<li>augmented grammar <code>$G'$</code>
<ul>
<li>將 <code>$G$</code> 的 start symbol 改為 <code>$S'$</code> 且 <code>$S' \to S$</code></li>
</ul>
</li>
<li>two function
<ul>
<li>CLOSURE</li>
<li>GOTO</li>
</ul>
</li>
<li>當 reduce 到 <code>$S' \to S$</code> 時可以 Accept</li>
<li>state 接受認得的 viable prefixes</li>
</ul>
<h5 id="lr-0-item">LR(0) item</h5>
<p><code>$A \to XYZ$</code> 包含 4 個 items:</p>
<ol>
<li><code>$A \to \cdot XYZ$</code>：希望在 input 上看到 XYZ</li>
<li><code>$A \to X \cdot YZ$</code>：剛看到 X 希望在 input 上看到 YZ</li>
<li><code>$A \to XY \cdot Z$</code>：剛看到 XY 希望在 input 上看到 Z</li>
<li><code>$A \to XYZ \cdot$</code>：reduce XYZ to A</li>
</ol>
<p><code>$A \to \varepsilon$</code> 僅包含 <code>$A \to \cdot$</code></p>
<p>item 又區分為兩類：</p>
<ol>
<li>Kernel items: initial item (<code>$S' \to \cdot S$</code>) 及 dot 不在最左邊的 items</li>
<li>Nonkernel items: dot 在最左邊的 items，除了initial item (<code>$S' \to \cdot S$</code>)</li>
</ol>
<h5 id="closure-i">CLOSURE(I)</h5>
<p><code>$I$</code>: grammar <code>$G$</code> 的 items set<br>
<code>$CLOSURE(I)$</code>: 由 <code>$I$</code> 構成的 items set</p>
<p>意義：在同一個 <code>$CLOSURE(I)$</code> 的 items 都屬於同一個 parsing state，用其紀錄我們在過去看到什麼還有在未來期望看到什麼</p>
<h5 id="goto-i-x">GOTO(I, X)</h5>
<p><code>$I$</code>: grammar <code>$G$</code> 的 items set<br>
<code>$X$</code>: <code>$G$</code> 的 grammar symbol<br>
<code>$GOTO(I, X)$</code>: if <code>$[A \to \alpha \cdot X \beta] \in I$</code>,then <code>$CLOSURE( \{ [A \to \alpha X \cdot \beta] \} ) \subseteq GOTO(I, X)$</code></p>
<p>意義：當看到 I 期望看到的 X，將 dot 往右移到 X 右方，並對其做 CLOSURE (像是 state transition)</p>
<h5 id="lr-0-collection">LR(0) Collection</h5>
<blockquote>
<p><code>$C = \{ CLOSURE(\{ S' \to \cdot S \}) \}$</code><br>
repeat<br>
　　for(each <code>$I$</code> in <code>$C$</code> and each grammar symbol <code>$X$</code>)<br>
　　　　if(<code>$GOTO(I, X)$</code> is not empty and not in <code>$C$</code>)<br>
　　　　　　add <code>$GOTO(I, X)$</code> to <code>$C$</code><br>
until no more set of LR(0) items can be added to C</p>
</blockquote>
<h4 id="lr-0-parsing">LR(0) Parsing</h4>
<p>LR parsing without lookahead symbols</p>
<ul>
<li>在 State <code>$Ii$</code> 的決策：
<ul>
<li>若 <code>$[A \to \alpha \cdot a \beta] \in Ii$</code>，當看到 terminal <code>$a$</code> 時做 shift
<ul>
<li>從 <code>$Ii$</code> 走到 <code>$CLOSURE(\{ [A \to \alpha a \cdot \beta] \})$</code></li>
</ul>
</li>
<li>若 <code>$[A \to \beta \cdot] \in Ii$</code>，做 reduce by <code>$A \to \beta$</code>
<ul>
<li>從 <code>$Ii$</code> 走到 <code>$GOTO(I, A)$</code>,<code>$I$</code> 是在 remove <code>$\beta$</code> 後 stack 的 top</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>See example in <a href="#shift-reduce-parsing">Shift-Reduce Parsing</a></p>
<div>$$
E' \to E\\
E \to E + T | T\\
T \to T * F | F\\
F \to (E) | id
$$</div>
<div>$$
input: id*id
$$</div>
<figure>
  <img src="/NCTU-Coursenote/img/compiler/2019-04-15-02-15-34.png" style="width: 75%">
  <figcaption>
      <p>Parsing table</p>
  </figcaption>
</figure>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Symbol</th>
<th>Input</th>
<th>Action</th>
<th>Transition</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>$</td>
<td>id * id$</td>
<td>shift to 5</td>
<td>I0 → I5</td>
</tr>
<tr>
<td>0 5</td>
<td>$id</td>
<td>* id$</td>
<td>reduce by F → id</td>
<td>I5 → GOTO(I0, F) – I3</td>
</tr>
<tr>
<td>0 3</td>
<td>$F</td>
<td>* id$</td>
<td>reduce by T → F</td>
<td>I3 → GOTO(I0, T) – I2</td>
</tr>
<tr>
<td>0 2</td>
<td>$T</td>
<td>* id$</td>
<td>shift to 7</td>
<td>I2 → I7</td>
</tr>
<tr>
<td>0 2 7</td>
<td>$T *</td>
<td>id$</td>
<td>shift to 5</td>
<td>I7 → I5</td>
</tr>
<tr>
<td>0 2 7 5</td>
<td>$T * id</td>
<td>$</td>
<td>reduce by F → id</td>
<td>I5 → GOTO(I7, F) – I10</td>
</tr>
<tr>
<td>0 2 7 10</td>
<td>$T * F</td>
<td>$</td>
<td>reduce by T → T * F</td>
<td>I10 → GOTO(I0, T) – I2</td>
</tr>
<tr>
<td>0 2</td>
<td>$T</td>
<td>$</td>
<td>reduce by E → T</td>
<td>I2 → GOTO(0, E) – I1</td>
</tr>
<tr>
<td>0 1</td>
<td>$E</td>
<td>$</td>
<td>accept</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="slr-parsing">SLR Parsing</h4>
<p>Simple LR Parsing</p>
<p><strong>LR(0) + FOLLOW Set = SLR(1)</strong> (簡稱SLR)</p>
<ul>
<li>在 State <code>$Ii$</code> 遇到 terminal <code>$a$</code> 的決策：
<ul>
<li>若 <code>$[A \to \alpha \cdot a \beta] \in Ii$</code>，shift
<ul>
<li>從 <code>$Ii$</code> 走到 <code>$CLOSURE(\{ [A \to \alpha a \cdot \beta] \})$</code></li>
</ul>
</li>
<li>若 <code>$[A \to \beta \cdot] \in Ii$</code> 且 <code>$a \in FOLLOW(A)$</code>，做 reduce by <code>$A \to \beta$</code>
<ul>
<li>從 <code>$Ii$</code> 走到 <code>$GOTO(I, A)$</code>,<code>$I$</code> 是在 remove <code>$\beta$</code> 後 stack 的 top</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="basic">Basic</h5>
<p>SLR parsing 之所以可以判斷要做 shift 或 reduce，是基於 LR(0) automata 識別 viable prefixes 的能力：</p>
<p><code>$S \overset{*}{\underset{rm}{\Rightarrow}} \alpha A w \underset{rm}{\Rightarrow} \alpha \beta_1 \beta_2 w$</code></p>
<ul>
<li><code>$[A \to \beta_1 \cdot \beta_2]$</code> is <strong>valid</strong> for <code>$\alpha \beta_1$</code>
<ul>
<li>若 <code>$\beta_2 \neq \varepsilon$</code> 代表還沒 shift handle 進 stack，所以做 shift</li>
<li>若 <code>$\beta_2 = \varepsilon$</code> 代表 <code>$\beta_1$</code> 為 handle，所以做 reduce</li>
</ul>
</li>
</ul>
<h5 id="model">Model</h5>
<p>維護兩個表 <strong>ACTION TABLE</strong> 及 <strong>GOTO TABLE</strong></p>
<p><img src="/NCTU-Coursenote/img/compiler/2019-04-15-03-09-26.png" alt></p>
<h5 id="slr-parsing-table">SLR Parsing Table</h5>
<ul>
<li>建構 LR(0) collection <code>$C = \{ I_0, I_1, ... , I_n \}$</code> for <code>$G'$</code></li>
<li><code>$ACTION[i, a] , a \in terminal$</code>
<ul>
<li>若 <code>$[A \to \alpha \cdot a \beta] \in I_i$</code> 且 <code>$GOTO(I_i, a) = I_j$</code>
<ul>
<li><code>$ACTION[i, a]$</code> = &quot;shift <code>$j$</code>&quot;</li>
</ul>
</li>
<li>若 <code>$[A \to \alpha \cdot] \in I_i$</code> 且 <code>$A \neq S$</code>
<ul>
<li><code>$ACTION[i, a]$</code> = &quot;reduce by <code>$A \to \alpha$</code>&quot; for all <code>$a \in FOLLOW(A)$</code></li>
</ul>
</li>
<li>若 <code>$[S' \to S \cdot] \in I_i$</code>
<ul>
<li><code>$ACTION[i, a]$</code> = “accept”</li>
</ul>
</li>
</ul>
</li>
<li><code>$GOTO[i, A] , A \in nonterminal$</code>
<ul>
<li>若 <code>$GOTO[I_i, A] = I_j$</code>
<ul>
<li><code>$GOTO[i, A] = j$</code></li>
</ul>
</li>
</ul>
</li>
<li>空的皆為 “error”</li>
<li>Initial state <code>$I_0$</code> 包含 <code>$[S' \to S]$</code></li>
</ul>
<p>若 step 2 出現 conflict，則這個 grammar 不是 SLR</p>
<h5 id="example">Example</h5>
<figure>
  <div>
    <img src="/NCTU-Coursenote/img/compiler/2019-04-15-02-15-34.png">
    <img src="/NCTU-Coursenote/img/compiler/2019-04-15-03-54-49.png">
  </div>
</figure>
<table>
<thead>
<tr>
<th>Stack</th>
<th>Symbol</th>
<th>Input</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>$</td>
<td>id * id + id$</td>
<td>s5</td>
</tr>
<tr>
<td>0</td>
<td>$id</td>
<td>* id + id$</td>
<td>r6</td>
</tr>
<tr>
<td>0 3</td>
<td>$F</td>
<td>* id + id$</td>
<td>r4</td>
</tr>
<tr>
<td>0 2</td>
<td>$T</td>
<td>* id + id$</td>
<td>s7</td>
</tr>
<tr>
<td>0 2 7</td>
<td>$T *</td>
<td>id + id$</td>
<td>s5</td>
</tr>
<tr>
<td>0 2 7 5</td>
<td>$T * id</td>
<td>+ id$</td>
<td>r6</td>
</tr>
<tr>
<td>0 2 7 10</td>
<td>$T * F</td>
<td>+ id$</td>
<td>r3</td>
</tr>
<tr>
<td>0 2</td>
<td>$T</td>
<td>+ id$</td>
<td>r2</td>
</tr>
<tr>
<td>0 1</td>
<td>$E</td>
<td>+ id$</td>
<td>s6</td>
</tr>
<tr>
<td>0 1 6</td>
<td>$E +</td>
<td>id$</td>
<td>s5</td>
</tr>
<tr>
<td>0 1 6 5</td>
<td>$E + id</td>
<td>$</td>
<td>r6</td>
</tr>
<tr>
<td>0 1 6 3</td>
<td>$E + F</td>
<td>$</td>
<td>r4</td>
</tr>
<tr>
<td>0 1 6 9</td>
<td>$E + T</td>
<td>$</td>
<td>r1</td>
</tr>
<tr>
<td>0 1</td>
<td>$E</td>
<td>$</td>
<td>acc</td>
</tr>
</tbody>
</table>
<h5 id="conflicts">Conflicts</h5>
<ul>
<li>shift/reduce conflict: state 不知道該做 shift 還是 reduce</li>
<li>reduce/reduce conflict: state 不知道該用哪個 reduce</li>
<li>若 grammar G 的 SLR parsing table 有 conflict，則 G 非 SLR Grammar</li>
</ul>
<h3 id="bottom">bottom</h3>

    </div>
    
    <div id="disqus_thread"></div>
    <script>
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://at881005.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
  <div class="column col-2">
    <div class="book-toc">
      <div class="book-tocbot">
      </div>
      <div class="book-tocbot-menu">
        <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
      </div>
    </div>
  </div>
</div>

<script>
tocbot.init({
  tocSelector: '.book-tocbot',
  contentSelector: '.book-post',
  headingSelector: 'h1, h2, h3, h4, h5',
  collapseDepth: 2,
  orderedList: false,
  scrollSmooth: false,
});

function expand_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 6,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "collapse_toc()");
  b.innerHTML = "Collapse all"
}

function collapse_toc(){
  var b = document.querySelector(".book-toc-expand");
  tocbot.init({
    tocSelector: '.book-tocbot',
    contentSelector: '.book-post',
    headingSelector: 'h1, h2, h3, h4, h5',
    collapseDepth: 2,
    orderedList: false,
    scrollSmooth: false,
  });
  b.setAttribute("onclick", "expand_toc()");
  b.innerHTML = "Expand all"
}

function go_top() {
  window.scrollTo(0, 0);
}

function go_bottom() {
  window.scrollTo(0, document.body.scrollHeight);
}

</script>


<script>
  $('.book-content img').each(function () {
      $(this).wrap("<a href='" + this.src + "'>").parent('a').addClass('gallery-item');
  })
  $(document).ready(function() {
    $(".book-content").lightGallery({
        selector: '.gallery-item'
    });
  });
</script>

        </div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
